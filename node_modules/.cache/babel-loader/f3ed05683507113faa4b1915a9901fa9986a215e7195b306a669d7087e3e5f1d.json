{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_expanded.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { toComparable } from \"../../../../core/utils/data\";\nimport { keysEqual } from \"../../../../data/utils\";\nimport { each } from \"../../../../core/utils/iterator\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport storeHelper from \"../../../../data/store_helper\";\nimport dataQuery from \"../../../../data/query\";\nimport { when, Deferred } from \"../../../../core/utils/deferred\";\nimport dataGridCore from \"../module_core\";\nimport { GroupingHelper as GroupingHelperCore, createOffsetFilter } from \"./module_core\";\nimport { createGroupFilter } from \"../module_utils\";\nconst loadTotalCount = function (dataSource, options) {\n  const d = new Deferred();\n  const loadOptions = extend({\n    skip: 0,\n    take: 1,\n    requireTotalCount: true\n  }, options);\n  dataSource.load(loadOptions).done((data, extra) => {\n    d.resolve(extra && extra.totalCount);\n  }).fail(d.reject.bind(d));\n  return d;\n};\nexport { loadTotalCount };\nexport const GroupingHelper = GroupingHelperCore.inherit(function () {\n  const foreachCollapsedGroups = function (that, callback, updateOffsets) {\n    return that.foreachGroups(groupInfo => {\n      if (!groupInfo.isExpanded) {\n        return callback(groupInfo);\n      }\n    }, false, false, updateOffsets, true);\n  };\n  const correctSkipLoadOption = function (that, skip) {\n    let skipCorrection = 0;\n    let resultSkip = skip || 0;\n    if (skip) {\n      foreachCollapsedGroups(that, groupInfo => {\n        if (groupInfo.offset - skipCorrection >= skip) {\n          return false;\n        }\n        skipCorrection += groupInfo.count - 1;\n      });\n      resultSkip += skipCorrection;\n    }\n    return resultSkip;\n  };\n  const processGroupItems = function (that, items, path, offset, skipFirstItem, take) {\n    let removeLastItemsCount = 0;\n    let needRemoveFirstItem = false;\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (void 0 !== item.items) {\n        path.push(item.key);\n        const groupInfo = that.findGroupInfo(path);\n        if (groupInfo && !groupInfo.isExpanded) {\n          item.collapsedItems = item.items;\n          item.items = null;\n          offset += groupInfo.count;\n          take--;\n          if (take < 0) {\n            removeLastItemsCount++;\n          }\n          if (skipFirstItem) {\n            needRemoveFirstItem = true;\n          }\n        } else if (item.items) {\n          const offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\n          if (skipFirstItem) {\n            if (offsetInfo.offset - offset > 1) {\n              item.isContinuation = true;\n            } else {\n              needRemoveFirstItem = true;\n            }\n          }\n          offset = offsetInfo.offset;\n          take = offsetInfo.take;\n          if (take < 0) {\n            if (item.items.length) {\n              item.isContinuationOnNextPage = true;\n            } else {\n              removeLastItemsCount++;\n            }\n          }\n        }\n        path.pop();\n      } else {\n        if (skipFirstItem) {\n          needRemoveFirstItem = true;\n        }\n        offset++;\n        take--;\n        if (take < 0) {\n          removeLastItemsCount++;\n        }\n      }\n      skipFirstItem = false;\n    }\n    if (needRemoveFirstItem) {\n      items.splice(0, 1);\n    }\n    if (removeLastItemsCount) {\n      items.splice(-removeLastItemsCount, removeLastItemsCount);\n    }\n    return {\n      offset: offset,\n      take: take\n    };\n  };\n  const pathEquals = function (path1, path2) {\n    if (path1.length !== path2.length) {\n      return false;\n    }\n    for (let i = 0; i < path1.length; i++) {\n      if (!keysEqual(null, path1[i], path2[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const updateGroupOffsets = function (that, items, path, offset, additionalGroupInfo) {\n    if (!items) {\n      return;\n    }\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (\"key\" in item && void 0 !== item.items) {\n        path.push(item.key);\n        if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\n          additionalGroupInfo.offset = offset;\n        }\n        const groupInfo = that.findGroupInfo(path);\n        if (groupInfo && !item.isContinuation) {\n          groupInfo.offset = offset;\n        }\n        if (groupInfo && !groupInfo.isExpanded) {\n          offset += groupInfo.count;\n        } else {\n          offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);\n        }\n        path.pop();\n      } else {\n        offset++;\n      }\n    }\n    return offset;\n  };\n  const getGroupCount = function (item, groupCount) {\n    let count = item.count || item.items.length;\n    if (!item.count && groupCount > 1) {\n      count = 0;\n      for (let i = 0; i < item.items.length; i++) {\n        count += getGroupCount(item.items[i], groupCount - 1);\n      }\n    }\n    return count;\n  };\n  return {\n    handleDataLoading(options) {\n      const {\n        storeLoadOptions: storeLoadOptions\n      } = options;\n      const collapsedGroups = [];\n      let collapsedItemsCount = 0;\n      let skipFirstItem = false;\n      let take;\n      const {\n        group: group\n      } = options.loadOptions;\n      let skipCorrection = 0;\n      !function (storeLoadOptions, loadOptions) {\n        if (loadOptions.group) {\n          const groups = dataGridCore.normalizeSortingInfo(loadOptions.group);\n          const sorts = dataGridCore.normalizeSortingInfo(storeLoadOptions.sort);\n          storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);\n          delete loadOptions.group;\n        }\n      }(storeLoadOptions, options.loadOptions);\n      options.group = options.group || group;\n      if (options.isCustomLoading) {\n        return;\n      }\n      const loadOptions = extend({}, storeLoadOptions);\n      loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);\n      if (loadOptions.skip && loadOptions.take && group) {\n        loadOptions.skip--;\n        loadOptions.take++;\n        skipFirstItem = true;\n      }\n      if (loadOptions.take && group) {\n        take = loadOptions.take;\n        loadOptions.take++;\n      }\n      foreachCollapsedGroups(this, groupInfo => {\n        if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\n          return false;\n        }\n        if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\n          skipCorrection += groupInfo.count - 1;\n          collapsedGroups.push(groupInfo);\n          collapsedItemsCount += groupInfo.count;\n        }\n      });\n      each(collapsedGroups, function () {\n        loadOptions.filter = function (path, storeLoadOptions, group) {\n          const groups = dataGridCore.normalizeSortingInfo(group || storeLoadOptions.group);\n          let filter = [];\n          for (let i = 0; i < path.length; i++) {\n            const filterElement = [];\n            for (let j = 0; j <= i; j++) {\n              filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]]);\n            }\n            filter.push(dataGridCore.combineFilters(filterElement));\n          }\n          filter = dataGridCore.combineFilters(filter, \"or\");\n          return dataGridCore.combineFilters([filter, storeLoadOptions.filter]);\n        }(this.path, loadOptions, group);\n      });\n      options.storeLoadOptions = loadOptions;\n      options.collapsedGroups = collapsedGroups;\n      options.collapsedItemsCount = collapsedItemsCount;\n      options.skip = loadOptions.skip || 0;\n      options.skipFirstItem = skipFirstItem;\n      options.take = take;\n    },\n    handleDataLoaded(options, callBase) {\n      const that = this;\n      const {\n        collapsedGroups: collapsedGroups\n      } = options;\n      const groups = dataGridCore.normalizeSortingInfo(options.group);\n      const groupCount = groups.length;\n      function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\n        if (!data || !path.length || !groups.length) {\n          return;\n        }\n        let keyValue;\n        let i;\n        const pathValue = toComparable(path[0], true);\n        for (i = 0; i < data.length; i++) {\n          keyValue = toComparable(data[i].key, true);\n          if (offset >= collapsedGroup.offset || pathValue === keyValue) {\n            break;\n          } else {\n            offset += getGroupCount(data[i], groups.length);\n          }\n        }\n        if (!data.length || pathValue !== keyValue) {\n          data.splice(i, 0, {\n            key: path[0],\n            items: [],\n            count: 1 === path.length ? collapsedGroup.count : void 0\n          });\n        }\n        appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset);\n      }\n      if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\n        if (!options.extra._totalCountWasIncreasedByCollapsedItems) {\n          options.extra.totalCount += options.collapsedItemsCount;\n          options.extra._totalCountWasIncreasedByCollapsedItems = true;\n        }\n      }\n      callBase(options);\n      if (groupCount) {\n        let {\n          data: data\n        } = options;\n        const query = dataQuery(data);\n        storeHelper.multiLevelGroup(query, groups).enumerate().done(groupedData => {\n          data = groupedData;\n        });\n        if (collapsedGroups) {\n          for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\n            appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);\n          }\n        }\n        if (!options.isCustomLoading) {\n          processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);\n        }\n        options.data = data;\n      }\n    },\n    isGroupItemCountable: item => null === item.items,\n    updateTotalItemsCount() {\n      let itemsCountCorrection = 0;\n      foreachCollapsedGroups(this, groupInfo => {\n        if (groupInfo.count) {\n          itemsCountCorrection -= groupInfo.count - 1;\n        }\n      });\n      this.callBase(itemsCountCorrection);\n    },\n    changeRowExpand(path) {\n      const that = this;\n      const dataSource = that._dataSource;\n      const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\n      const dataSourceItems = dataSource.items();\n      const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\n      let groupInfo = that.findGroupInfo(path);\n      let groupCountQuery;\n      if (groupInfo && !groupInfo.isExpanded) {\n        groupCountQuery = new Deferred().resolve(groupInfo.count);\n      } else {\n        groupCountQuery = loadTotalCount(dataSource, {\n          filter: createGroupFilter(path, {\n            filter: dataSource.filter(),\n            group: dataSource.group()\n          })\n        });\n      }\n      return when(groupCountQuery).done(count => {\n        count = parseInt(count.length ? count[0] : count);\n        if (groupInfo) {\n          updateGroupOffsets(that, dataSourceItems, [], offset);\n          groupInfo.isExpanded = !groupInfo.isExpanded;\n          groupInfo.count = count;\n        } else {\n          groupInfo = {\n            offset: -1,\n            count: count,\n            path: path,\n            isExpanded: false\n          };\n          updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\n          if (groupInfo.offset >= 0) {\n            that.addGroupInfo(groupInfo);\n          }\n        }\n        that.updateTotalItemsCount();\n      }).fail(function () {\n        dataSource._eventsStrategy.fireEvent(\"loadError\", arguments);\n      });\n    },\n    allowCollapseAll: () => false,\n    refresh(options, operationTypes) {\n      const that = this;\n      const {\n        storeLoadOptions: storeLoadOptions\n      } = options;\n      const dataSource = that._dataSource;\n      this.callBase.apply(this, arguments);\n      if (operationTypes.reload) {\n        return foreachCollapsedGroups(that, groupInfo => {\n          const groupCountQuery = loadTotalCount(dataSource, {\n            filter: createGroupFilter(groupInfo.path, storeLoadOptions)\n          });\n          const groupOffsetQuery = loadTotalCount(dataSource, {\n            filter: createOffsetFilter(groupInfo.path, storeLoadOptions)\n          });\n          return when(groupOffsetQuery, groupCountQuery).done((offset, count) => {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount();\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());","map":{"version":3,"names":["toComparable","keysEqual","each","extend","storeHelper","dataQuery","when","Deferred","dataGridCore","GroupingHelper","GroupingHelperCore","createOffsetFilter","createGroupFilter","loadTotalCount","dataSource","options","d","loadOptions","skip","take","requireTotalCount","load","done","data","extra","resolve","totalCount","fail","reject","bind","inherit","foreachCollapsedGroups","that","callback","updateOffsets","foreachGroups","groupInfo","isExpanded","correctSkipLoadOption","skipCorrection","resultSkip","offset","count","processGroupItems","items","path","skipFirstItem","removeLastItemsCount","needRemoveFirstItem","i","length","item","push","key","findGroupInfo","collapsedItems","offsetInfo","isContinuation","isContinuationOnNextPage","pop","splice","pathEquals","path1","path2","updateGroupOffsets","additionalGroupInfo","getGroupCount","groupCount","handleDataLoading","storeLoadOptions","collapsedGroups","collapsedItemsCount","group","groups","normalizeSortingInfo","sorts","sort","arrangeSortingInfo","isCustomLoading","filter","filterElement","j","selector","combineFilters","handleDataLoaded","callBase","appendCollapsedPath","collapsedGroup","keyValue","pathValue","slice","_totalCountWasIncreasedByCollapsedItems","query","multiLevelGroup","enumerate","groupedData","pathIndex","isGroupItemCountable","updateTotalItemsCount","itemsCountCorrection","changeRowExpand","_dataSource","beginPageIndex","pageIndex","dataSourceItems","pageSize","groupCountQuery","parseInt","addGroupInfo","_eventsStrategy","fireEvent","arguments","allowCollapseAll","refresh","operationTypes","apply","reload","groupOffsetQuery"],"sources":["C:/Users/ninad/OneDrive/Radna površina/zavrsni/client/node_modules/devextreme/esm/__internal/grids/data_grid/grouping/module_expanded.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_expanded.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    toComparable\r\n} from \"../../../../core/utils/data\";\r\nimport {\r\n    keysEqual\r\n} from \"../../../../data/utils\";\r\nimport {\r\n    each\r\n} from \"../../../../core/utils/iterator\";\r\nimport {\r\n    extend\r\n} from \"../../../../core/utils/extend\";\r\nimport storeHelper from \"../../../../data/store_helper\";\r\nimport dataQuery from \"../../../../data/query\";\r\nimport {\r\n    when,\r\n    Deferred\r\n} from \"../../../../core/utils/deferred\";\r\nimport dataGridCore from \"../module_core\";\r\nimport {\r\n    GroupingHelper as GroupingHelperCore,\r\n    createOffsetFilter\r\n} from \"./module_core\";\r\nimport {\r\n    createGroupFilter\r\n} from \"../module_utils\";\r\nconst loadTotalCount = function(dataSource, options) {\r\n    const d = new Deferred;\r\n    const loadOptions = extend({\r\n        skip: 0,\r\n        take: 1,\r\n        requireTotalCount: true\r\n    }, options);\r\n    dataSource.load(loadOptions).done((data, extra) => {\r\n        d.resolve(extra && extra.totalCount)\r\n    }).fail(d.reject.bind(d));\r\n    return d\r\n};\r\nexport {\r\n    loadTotalCount\r\n};\r\nexport const GroupingHelper = GroupingHelperCore.inherit(function() {\r\n    const foreachCollapsedGroups = function(that, callback, updateOffsets) {\r\n        return that.foreachGroups(groupInfo => {\r\n            if (!groupInfo.isExpanded) {\r\n                return callback(groupInfo)\r\n            }\r\n        }, false, false, updateOffsets, true)\r\n    };\r\n    const correctSkipLoadOption = function(that, skip) {\r\n        let skipCorrection = 0;\r\n        let resultSkip = skip || 0;\r\n        if (skip) {\r\n            foreachCollapsedGroups(that, groupInfo => {\r\n                if (groupInfo.offset - skipCorrection >= skip) {\r\n                    return false\r\n                }\r\n                skipCorrection += groupInfo.count - 1\r\n            });\r\n            resultSkip += skipCorrection\r\n        }\r\n        return resultSkip\r\n    };\r\n    const processGroupItems = function(that, items, path, offset, skipFirstItem, take) {\r\n        let removeLastItemsCount = 0;\r\n        let needRemoveFirstItem = false;\r\n        for (let i = 0; i < items.length; i++) {\r\n            const item = items[i];\r\n            if (void 0 !== item.items) {\r\n                path.push(item.key);\r\n                const groupInfo = that.findGroupInfo(path);\r\n                if (groupInfo && !groupInfo.isExpanded) {\r\n                    item.collapsedItems = item.items;\r\n                    item.items = null;\r\n                    offset += groupInfo.count;\r\n                    take--;\r\n                    if (take < 0) {\r\n                        removeLastItemsCount++\r\n                    }\r\n                    if (skipFirstItem) {\r\n                        needRemoveFirstItem = true\r\n                    }\r\n                } else if (item.items) {\r\n                    const offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\r\n                    if (skipFirstItem) {\r\n                        if (offsetInfo.offset - offset > 1) {\r\n                            item.isContinuation = true\r\n                        } else {\r\n                            needRemoveFirstItem = true\r\n                        }\r\n                    }\r\n                    offset = offsetInfo.offset;\r\n                    take = offsetInfo.take;\r\n                    if (take < 0) {\r\n                        if (item.items.length) {\r\n                            item.isContinuationOnNextPage = true\r\n                        } else {\r\n                            removeLastItemsCount++\r\n                        }\r\n                    }\r\n                }\r\n                path.pop()\r\n            } else {\r\n                if (skipFirstItem) {\r\n                    needRemoveFirstItem = true\r\n                }\r\n                offset++;\r\n                take--;\r\n                if (take < 0) {\r\n                    removeLastItemsCount++\r\n                }\r\n            }\r\n            skipFirstItem = false\r\n        }\r\n        if (needRemoveFirstItem) {\r\n            items.splice(0, 1)\r\n        }\r\n        if (removeLastItemsCount) {\r\n            items.splice(-removeLastItemsCount, removeLastItemsCount)\r\n        }\r\n        return {\r\n            offset: offset,\r\n            take: take\r\n        }\r\n    };\r\n    const pathEquals = function(path1, path2) {\r\n        if (path1.length !== path2.length) {\r\n            return false\r\n        }\r\n        for (let i = 0; i < path1.length; i++) {\r\n            if (!keysEqual(null, path1[i], path2[i])) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    };\r\n    const updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {\r\n        if (!items) {\r\n            return\r\n        }\r\n        for (let i = 0; i < items.length; i++) {\r\n            const item = items[i];\r\n            if (\"key\" in item && void 0 !== item.items) {\r\n                path.push(item.key);\r\n                if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\r\n                    additionalGroupInfo.offset = offset\r\n                }\r\n                const groupInfo = that.findGroupInfo(path);\r\n                if (groupInfo && !item.isContinuation) {\r\n                    groupInfo.offset = offset\r\n                }\r\n                if (groupInfo && !groupInfo.isExpanded) {\r\n                    offset += groupInfo.count\r\n                } else {\r\n                    offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo)\r\n                }\r\n                path.pop()\r\n            } else {\r\n                offset++\r\n            }\r\n        }\r\n        return offset\r\n    };\r\n    const getGroupCount = function(item, groupCount) {\r\n        let count = item.count || item.items.length;\r\n        if (!item.count && groupCount > 1) {\r\n            count = 0;\r\n            for (let i = 0; i < item.items.length; i++) {\r\n                count += getGroupCount(item.items[i], groupCount - 1)\r\n            }\r\n        }\r\n        return count\r\n    };\r\n    return {\r\n        handleDataLoading(options) {\r\n            const {\r\n                storeLoadOptions: storeLoadOptions\r\n            } = options;\r\n            const collapsedGroups = [];\r\n            let collapsedItemsCount = 0;\r\n            let skipFirstItem = false;\r\n            let take;\r\n            const {\r\n                group: group\r\n            } = options.loadOptions;\r\n            let skipCorrection = 0;\r\n            ! function(storeLoadOptions, loadOptions) {\r\n                if (loadOptions.group) {\r\n                    const groups = dataGridCore.normalizeSortingInfo(loadOptions.group);\r\n                    const sorts = dataGridCore.normalizeSortingInfo(storeLoadOptions.sort);\r\n                    storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);\r\n                    delete loadOptions.group\r\n                }\r\n            }(storeLoadOptions, options.loadOptions);\r\n            options.group = options.group || group;\r\n            if (options.isCustomLoading) {\r\n                return\r\n            }\r\n            const loadOptions = extend({}, storeLoadOptions);\r\n            loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);\r\n            if (loadOptions.skip && loadOptions.take && group) {\r\n                loadOptions.skip--;\r\n                loadOptions.take++;\r\n                skipFirstItem = true\r\n            }\r\n            if (loadOptions.take && group) {\r\n                take = loadOptions.take;\r\n                loadOptions.take++\r\n            }\r\n            foreachCollapsedGroups(this, groupInfo => {\r\n                if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\r\n                    return false\r\n                }\r\n                if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\r\n                    skipCorrection += groupInfo.count - 1;\r\n                    collapsedGroups.push(groupInfo);\r\n                    collapsedItemsCount += groupInfo.count\r\n                }\r\n            });\r\n            each(collapsedGroups, (function() {\r\n                loadOptions.filter = function(path, storeLoadOptions, group) {\r\n                    const groups = dataGridCore.normalizeSortingInfo(group || storeLoadOptions.group);\r\n                    let filter = [];\r\n                    for (let i = 0; i < path.length; i++) {\r\n                        const filterElement = [];\r\n                        for (let j = 0; j <= i; j++) {\r\n                            filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]])\r\n                        }\r\n                        filter.push(dataGridCore.combineFilters(filterElement))\r\n                    }\r\n                    filter = dataGridCore.combineFilters(filter, \"or\");\r\n                    return dataGridCore.combineFilters([filter, storeLoadOptions.filter])\r\n                }(this.path, loadOptions, group)\r\n            }));\r\n            options.storeLoadOptions = loadOptions;\r\n            options.collapsedGroups = collapsedGroups;\r\n            options.collapsedItemsCount = collapsedItemsCount;\r\n            options.skip = loadOptions.skip || 0;\r\n            options.skipFirstItem = skipFirstItem;\r\n            options.take = take\r\n        },\r\n        handleDataLoaded(options, callBase) {\r\n            const that = this;\r\n            const {\r\n                collapsedGroups: collapsedGroups\r\n            } = options;\r\n            const groups = dataGridCore.normalizeSortingInfo(options.group);\r\n            const groupCount = groups.length;\r\n\r\n            function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\r\n                if (!data || !path.length || !groups.length) {\r\n                    return\r\n                }\r\n                let keyValue;\r\n                let i;\r\n                const pathValue = toComparable(path[0], true);\r\n                for (i = 0; i < data.length; i++) {\r\n                    keyValue = toComparable(data[i].key, true);\r\n                    if (offset >= collapsedGroup.offset || pathValue === keyValue) {\r\n                        break\r\n                    } else {\r\n                        offset += getGroupCount(data[i], groups.length)\r\n                    }\r\n                }\r\n                if (!data.length || pathValue !== keyValue) {\r\n                    data.splice(i, 0, {\r\n                        key: path[0],\r\n                        items: [],\r\n                        count: 1 === path.length ? collapsedGroup.count : void 0\r\n                    })\r\n                }\r\n                appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset)\r\n            }\r\n            if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\r\n                if (!options.extra._totalCountWasIncreasedByCollapsedItems) {\r\n                    options.extra.totalCount += options.collapsedItemsCount;\r\n                    options.extra._totalCountWasIncreasedByCollapsedItems = true\r\n                }\r\n            }\r\n            callBase(options);\r\n            if (groupCount) {\r\n                let {\r\n                    data: data\r\n                } = options;\r\n                const query = dataQuery(data);\r\n                storeHelper.multiLevelGroup(query, groups).enumerate().done(groupedData => {\r\n                    data = groupedData\r\n                });\r\n                if (collapsedGroups) {\r\n                    for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\r\n                        appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip)\r\n                    }\r\n                }\r\n                if (!options.isCustomLoading) {\r\n                    processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take)\r\n                }\r\n                options.data = data\r\n            }\r\n        },\r\n        isGroupItemCountable: item => null === item.items,\r\n        updateTotalItemsCount() {\r\n            let itemsCountCorrection = 0;\r\n            foreachCollapsedGroups(this, groupInfo => {\r\n                if (groupInfo.count) {\r\n                    itemsCountCorrection -= groupInfo.count - 1\r\n                }\r\n            });\r\n            this.callBase(itemsCountCorrection)\r\n        },\r\n        changeRowExpand(path) {\r\n            const that = this;\r\n            const dataSource = that._dataSource;\r\n            const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\r\n            const dataSourceItems = dataSource.items();\r\n            const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\r\n            let groupInfo = that.findGroupInfo(path);\r\n            let groupCountQuery;\r\n            if (groupInfo && !groupInfo.isExpanded) {\r\n                groupCountQuery = (new Deferred).resolve(groupInfo.count)\r\n            } else {\r\n                groupCountQuery = loadTotalCount(dataSource, {\r\n                    filter: createGroupFilter(path, {\r\n                        filter: dataSource.filter(),\r\n                        group: dataSource.group()\r\n                    })\r\n                })\r\n            }\r\n            return when(groupCountQuery).done(count => {\r\n                count = parseInt(count.length ? count[0] : count);\r\n                if (groupInfo) {\r\n                    updateGroupOffsets(that, dataSourceItems, [], offset);\r\n                    groupInfo.isExpanded = !groupInfo.isExpanded;\r\n                    groupInfo.count = count\r\n                } else {\r\n                    groupInfo = {\r\n                        offset: -1,\r\n                        count: count,\r\n                        path: path,\r\n                        isExpanded: false\r\n                    };\r\n                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\r\n                    if (groupInfo.offset >= 0) {\r\n                        that.addGroupInfo(groupInfo)\r\n                    }\r\n                }\r\n                that.updateTotalItemsCount()\r\n            }).fail((function() {\r\n                dataSource._eventsStrategy.fireEvent(\"loadError\", arguments)\r\n            }))\r\n        },\r\n        allowCollapseAll: () => false,\r\n        refresh(options, operationTypes) {\r\n            const that = this;\r\n            const {\r\n                storeLoadOptions: storeLoadOptions\r\n            } = options;\r\n            const dataSource = that._dataSource;\r\n            this.callBase.apply(this, arguments);\r\n            if (operationTypes.reload) {\r\n                return foreachCollapsedGroups(that, groupInfo => {\r\n                    const groupCountQuery = loadTotalCount(dataSource, {\r\n                        filter: createGroupFilter(groupInfo.path, storeLoadOptions)\r\n                    });\r\n                    const groupOffsetQuery = loadTotalCount(dataSource, {\r\n                        filter: createOffsetFilter(groupInfo.path, storeLoadOptions)\r\n                    });\r\n                    return when(groupOffsetQuery, groupCountQuery).done((offset, count) => {\r\n                        offset = parseInt(offset.length ? offset[0] : offset);\r\n                        count = parseInt(count.length ? count[0] : count);\r\n                        groupInfo.offset = offset;\r\n                        if (groupInfo.count !== count) {\r\n                            groupInfo.count = count;\r\n                            that.updateTotalItemsCount()\r\n                        }\r\n                    })\r\n                }, true)\r\n            }\r\n        }\r\n    }\r\n}());\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}