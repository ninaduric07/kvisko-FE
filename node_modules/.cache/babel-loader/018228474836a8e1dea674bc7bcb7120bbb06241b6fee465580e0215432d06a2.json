{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_core.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../../../core/renderer\";\nimport Class from \"../../../../core/class\";\nimport { normalizeSortingInfo } from \"../../../../data/utils\";\nimport { when } from \"../../../../core/utils/deferred\";\nimport gridCore from \"../module_core\";\nexport function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {\n  const groups = normalizeSortingInfo(storeLoadOptions.group);\n  let filter = [];\n  for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {\n    const filterElement = [];\n    for (let j = 0; j <= i; j++) {\n      const {\n        selector: selector\n      } = groups[j];\n      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {\n        if (false === path[j]) {\n          filterElement.push([selector, \"=\", groups[j].desc ? true : null]);\n        } else if (path[j] ? !groups[j].desc : groups[j].desc) {\n          filterElement.push([selector, \"<>\", path[j]]);\n        } else {\n          filterElement.push([selector, \"<>\", null]);\n          filterElement.push([selector, \"=\", null]);\n        }\n      } else {\n        const currentFilter = [selector, i === j ? groups[j].desc ? \">\" : \"<\" : \"=\", path[j]];\n        if (\"<\" === currentFilter[1]) {\n          filterElement.push([currentFilter, \"or\", [selector, \"=\", null]]);\n        } else {\n          filterElement.push(currentFilter);\n        }\n      }\n    }\n    filter.push(gridCore.combineFilters(filterElement));\n  }\n  filter = gridCore.combineFilters(filter, \"or\");\n  return gridCore.combineFilters([filter, storeLoadOptions.filter]);\n}\nexport const GroupingHelper = Class.inherit(function () {\n  const findGroupInfoByKey = function (groupsInfo, key) {\n    const {\n      hash: hash\n    } = groupsInfo;\n    return hash && hash[JSON.stringify(key)];\n  };\n  const getGroupInfoIndexByOffset = function (groupsInfo, offset) {\n    let leftIndex = 0;\n    let rightIndex = groupsInfo.length - 1;\n    if (!groupsInfo.length) {\n      return 0;\n    }\n    do {\n      const middleIndex = rightIndex + leftIndex >> 1;\n      if (groupsInfo[middleIndex].offset > offset) {\n        rightIndex = middleIndex;\n      } else {\n        leftIndex = middleIndex;\n      }\n    } while (rightIndex - leftIndex > 1);\n    let index;\n    for (index = leftIndex; index <= rightIndex; index++) {\n      if (groupsInfo[index].offset > offset) {\n        break;\n      }\n    }\n    return index;\n  };\n  const cleanGroupsInfo = function (groupsInfo, groupIndex, groupsCount) {\n    for (let i = 0; i < groupsInfo.length; i++) {\n      if (groupIndex + 1 >= groupsCount) {\n        groupsInfo[i].children = [];\n      } else {\n        cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);\n      }\n    }\n  };\n  const calculateItemsCount = function (that, items, groupsCount) {\n    let result = 0;\n    if (items) {\n      if (!groupsCount) {\n        result = items.length;\n      } else {\n        for (let i = 0; i < items.length; i++) {\n          if (that.isGroupItemCountable(items[i])) {\n            result++;\n          }\n          result += calculateItemsCount(that, items[i].items, groupsCount - 1);\n        }\n      }\n    }\n    return result;\n  };\n  return {\n    ctor(dataSourceAdapter) {\n      this._dataSource = dataSourceAdapter;\n      this.reset();\n    },\n    reset() {\n      this._groupsInfo = [];\n      this._totalCountCorrection = 0;\n    },\n    totalCountCorrection() {\n      return this._totalCountCorrection;\n    },\n    updateTotalItemsCount(totalCountCorrection) {\n      this._totalCountCorrection = totalCountCorrection || 0;\n    },\n    isGroupItemCountable(item) {\n      return !this._isVirtualPaging() || !item.isContinuation;\n    },\n    _isVirtualPaging() {\n      const scrollingMode = this._dataSource.option(\"scrolling.mode\");\n      return \"virtual\" === scrollingMode || \"infinite\" === scrollingMode;\n    },\n    itemsCount() {\n      const dataSourceAdapter = this._dataSource;\n      const dataSource = dataSourceAdapter._dataSource;\n      const groupCount = gridCore.normalizeSortingInfo(dataSource.group() || []).length;\n      const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);\n      return itemsCount;\n    },\n    foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {\n      const that = this;\n      return function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {\n        const callbackResults = [];\n        function executeCallback(callback, data, parents, callbackResults) {\n          const callbackResult = data && callback(data, parents);\n          callbackResult && callbackResults.push(callbackResult);\n          return callbackResult;\n        }\n        for (let i = 0; i < groupsInfo.length; i++) {\n          parents.push(groupsInfo[i].data);\n          if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n            return false;\n          }\n          if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {\n            const {\n              children: children\n            } = groupsInfo[i];\n            const callbackResult = children.length && foreachGroupsCore(children, callback, childrenAtFirst, parents);\n            callbackResult && callbackResults.push(callbackResult);\n            if (false === callbackResult) {\n              return false;\n            }\n          }\n          if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n            return false;\n          }\n          if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {\n            updateOffsets = true;\n          }\n          parents.pop();\n        }\n        const currentParents = updateParentOffsets && parents.slice(0);\n        return updateOffsets && when.apply($, callbackResults).always(() => {\n          that._updateGroupInfoOffsets(groupsInfo, currentParents);\n        });\n      }(that._groupsInfo, callback, childrenAtFirst, []);\n    },\n    _updateGroupInfoOffsets(groupsInfo, parents) {\n      parents = parents || [];\n      for (let index = 0; index < groupsInfo.length; index++) {\n        const groupInfo = groupsInfo[index];\n        if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {\n          groupInfo.offset = groupInfo.data.offset;\n          for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {\n            parents[parentIndex].offset = groupInfo.offset;\n          }\n        }\n      }\n      groupsInfo.sort((a, b) => a.offset - b.offset);\n    },\n    findGroupInfo(path) {\n      let groupInfo;\n      let groupsInfo = this._groupsInfo;\n      for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {\n        groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n        groupsInfo = groupInfo && groupInfo.children;\n      }\n      return groupInfo && groupInfo.data;\n    },\n    addGroupInfo(groupInfoData) {\n      const that = this;\n      let groupInfo;\n      const {\n        path: path\n      } = groupInfoData;\n      let groupsInfo = that._groupsInfo;\n      for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {\n        groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n        if (!groupInfo) {\n          groupInfo = {\n            key: path[pathIndex],\n            offset: groupInfoData.offset,\n            data: {\n              offset: groupInfoData.offset,\n              isExpanded: true,\n              path: path.slice(0, pathIndex + 1)\n            },\n            children: []\n          };\n          const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);\n          groupsInfo.splice(index, 0, groupInfo);\n          groupsInfo.hash = groupsInfo.hash || {};\n          groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;\n        }\n        if (pathIndex === path.length - 1) {\n          groupInfo.data = groupInfoData;\n          if (groupInfo.offset !== groupInfoData.offset) {\n            that._updateGroupInfoOffsets(groupsInfo);\n          }\n        }\n        groupsInfo = groupInfo.children;\n      }\n    },\n    allowCollapseAll: () => true,\n    refresh(options) {\n      const that = this;\n      const {\n        storeLoadOptions: storeLoadOptions\n      } = options;\n      const groups = normalizeSortingInfo(storeLoadOptions.group || []);\n      const oldGroups = \"_group\" in that ? normalizeSortingInfo(that._group || []) : groups;\n      let groupsCount = Math.min(oldGroups.length, groups.length);\n      that._group = storeLoadOptions.group;\n      for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n        if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {\n          groupsCount = groupIndex;\n          break;\n        }\n      }\n      if (!groupsCount) {\n        that.reset();\n      } else {\n        cleanGroupsInfo(that._groupsInfo, 0, groupsCount);\n      }\n    },\n    handleDataLoading() {},\n    handleDataLoaded(options, callBase) {\n      callBase(options);\n    },\n    handleDataLoadedCore(options, callBase) {\n      callBase(options);\n    }\n  };\n}());","map":{"version":3,"names":["$","Class","normalizeSortingInfo","when","gridCore","createOffsetFilter","path","storeLoadOptions","lastLevelOnly","groups","group","filter","i","length","filterElement","j","selector","push","desc","currentFilter","combineFilters","GroupingHelper","inherit","findGroupInfoByKey","groupsInfo","key","hash","JSON","stringify","getGroupInfoIndexByOffset","offset","leftIndex","rightIndex","middleIndex","index","cleanGroupsInfo","groupIndex","groupsCount","children","calculateItemsCount","that","items","result","isGroupItemCountable","ctor","dataSourceAdapter","_dataSource","reset","_groupsInfo","_totalCountCorrection","totalCountCorrection","updateTotalItemsCount","item","_isVirtualPaging","isContinuation","scrollingMode","option","itemsCount","dataSource","groupCount","foreachGroups","callback","childrenAtFirst","foreachCollapsedGroups","updateOffsets","updateParentOffsets","foreachGroupsCore","parents","callbackResults","executeCallback","data","callbackResult","isExpanded","pop","currentParents","slice","apply","always","_updateGroupInfoOffsets","groupInfo","parentIndex","sort","a","b","findGroupInfo","pathIndex","addGroupInfo","groupInfoData","splice","allowCollapseAll","refresh","options","oldGroups","_group","Math","min","handleDataLoading","handleDataLoaded","callBase","handleDataLoadedCore"],"sources":["C:/Users/ninad/OneDrive/Radna povrÅ¡ina/zavrsni/client/node_modules/devextreme/esm/__internal/grids/data_grid/grouping/module_core.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_core.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport $ from \"../../../../core/renderer\";\r\nimport Class from \"../../../../core/class\";\r\nimport {\r\n    normalizeSortingInfo\r\n} from \"../../../../data/utils\";\r\nimport {\r\n    when\r\n} from \"../../../../core/utils/deferred\";\r\nimport gridCore from \"../module_core\";\r\nexport function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {\r\n    const groups = normalizeSortingInfo(storeLoadOptions.group);\r\n    let filter = [];\r\n    for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {\r\n        const filterElement = [];\r\n        for (let j = 0; j <= i; j++) {\r\n            const {\r\n                selector: selector\r\n            } = groups[j];\r\n            if (i === j && (null === path[j] || false === path[j] || true === path[j])) {\r\n                if (false === path[j]) {\r\n                    filterElement.push([selector, \"=\", groups[j].desc ? true : null])\r\n                } else if (path[j] ? !groups[j].desc : groups[j].desc) {\r\n                    filterElement.push([selector, \"<>\", path[j]])\r\n                } else {\r\n                    filterElement.push([selector, \"<>\", null]);\r\n                    filterElement.push([selector, \"=\", null])\r\n                }\r\n            } else {\r\n                const currentFilter = [selector, i === j ? groups[j].desc ? \">\" : \"<\" : \"=\", path[j]];\r\n                if (\"<\" === currentFilter[1]) {\r\n                    filterElement.push([currentFilter, \"or\", [selector, \"=\", null]])\r\n                } else {\r\n                    filterElement.push(currentFilter)\r\n                }\r\n            }\r\n        }\r\n        filter.push(gridCore.combineFilters(filterElement))\r\n    }\r\n    filter = gridCore.combineFilters(filter, \"or\");\r\n    return gridCore.combineFilters([filter, storeLoadOptions.filter])\r\n}\r\nexport const GroupingHelper = Class.inherit(function() {\r\n    const findGroupInfoByKey = function(groupsInfo, key) {\r\n        const {\r\n            hash: hash\r\n        } = groupsInfo;\r\n        return hash && hash[JSON.stringify(key)]\r\n    };\r\n    const getGroupInfoIndexByOffset = function(groupsInfo, offset) {\r\n        let leftIndex = 0;\r\n        let rightIndex = groupsInfo.length - 1;\r\n        if (!groupsInfo.length) {\r\n            return 0\r\n        }\r\n        do {\r\n            const middleIndex = rightIndex + leftIndex >> 1;\r\n            if (groupsInfo[middleIndex].offset > offset) {\r\n                rightIndex = middleIndex\r\n            } else {\r\n                leftIndex = middleIndex\r\n            }\r\n        } while (rightIndex - leftIndex > 1);\r\n        let index;\r\n        for (index = leftIndex; index <= rightIndex; index++) {\r\n            if (groupsInfo[index].offset > offset) {\r\n                break\r\n            }\r\n        }\r\n        return index\r\n    };\r\n    const cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {\r\n        for (let i = 0; i < groupsInfo.length; i++) {\r\n            if (groupIndex + 1 >= groupsCount) {\r\n                groupsInfo[i].children = []\r\n            } else {\r\n                cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)\r\n            }\r\n        }\r\n    };\r\n    const calculateItemsCount = function(that, items, groupsCount) {\r\n        let result = 0;\r\n        if (items) {\r\n            if (!groupsCount) {\r\n                result = items.length\r\n            } else {\r\n                for (let i = 0; i < items.length; i++) {\r\n                    if (that.isGroupItemCountable(items[i])) {\r\n                        result++\r\n                    }\r\n                    result += calculateItemsCount(that, items[i].items, groupsCount - 1)\r\n                }\r\n            }\r\n        }\r\n        return result\r\n    };\r\n    return {\r\n        ctor(dataSourceAdapter) {\r\n            this._dataSource = dataSourceAdapter;\r\n            this.reset()\r\n        },\r\n        reset() {\r\n            this._groupsInfo = [];\r\n            this._totalCountCorrection = 0\r\n        },\r\n        totalCountCorrection() {\r\n            return this._totalCountCorrection\r\n        },\r\n        updateTotalItemsCount(totalCountCorrection) {\r\n            this._totalCountCorrection = totalCountCorrection || 0\r\n        },\r\n        isGroupItemCountable(item) {\r\n            return !this._isVirtualPaging() || !item.isContinuation\r\n        },\r\n        _isVirtualPaging() {\r\n            const scrollingMode = this._dataSource.option(\"scrolling.mode\");\r\n            return \"virtual\" === scrollingMode || \"infinite\" === scrollingMode\r\n        },\r\n        itemsCount() {\r\n            const dataSourceAdapter = this._dataSource;\r\n            const dataSource = dataSourceAdapter._dataSource;\r\n            const groupCount = gridCore.normalizeSortingInfo(dataSource.group() || []).length;\r\n            const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);\r\n            return itemsCount\r\n        },\r\n        foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {\r\n            const that = this;\r\n            return function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {\r\n                const callbackResults = [];\r\n\r\n                function executeCallback(callback, data, parents, callbackResults) {\r\n                    const callbackResult = data && callback(data, parents);\r\n                    callbackResult && callbackResults.push(callbackResult);\r\n                    return callbackResult\r\n                }\r\n                for (let i = 0; i < groupsInfo.length; i++) {\r\n                    parents.push(groupsInfo[i].data);\r\n                    if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\r\n                        return false\r\n                    }\r\n                    if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {\r\n                        const {\r\n                            children: children\r\n                        } = groupsInfo[i];\r\n                        const callbackResult = children.length && foreachGroupsCore(children, callback, childrenAtFirst, parents);\r\n                        callbackResult && callbackResults.push(callbackResult);\r\n                        if (false === callbackResult) {\r\n                            return false\r\n                        }\r\n                    }\r\n                    if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\r\n                        return false\r\n                    }\r\n                    if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {\r\n                        updateOffsets = true\r\n                    }\r\n                    parents.pop()\r\n                }\r\n                const currentParents = updateParentOffsets && parents.slice(0);\r\n                return updateOffsets && when.apply($, callbackResults).always(() => {\r\n                    that._updateGroupInfoOffsets(groupsInfo, currentParents)\r\n                })\r\n            }(that._groupsInfo, callback, childrenAtFirst, [])\r\n        },\r\n        _updateGroupInfoOffsets(groupsInfo, parents) {\r\n            parents = parents || [];\r\n            for (let index = 0; index < groupsInfo.length; index++) {\r\n                const groupInfo = groupsInfo[index];\r\n                if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {\r\n                    groupInfo.offset = groupInfo.data.offset;\r\n                    for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {\r\n                        parents[parentIndex].offset = groupInfo.offset\r\n                    }\r\n                }\r\n            }\r\n            groupsInfo.sort((a, b) => a.offset - b.offset)\r\n        },\r\n        findGroupInfo(path) {\r\n            let groupInfo;\r\n            let groupsInfo = this._groupsInfo;\r\n            for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {\r\n                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\r\n                groupsInfo = groupInfo && groupInfo.children\r\n            }\r\n            return groupInfo && groupInfo.data\r\n        },\r\n        addGroupInfo(groupInfoData) {\r\n            const that = this;\r\n            let groupInfo;\r\n            const {\r\n                path: path\r\n            } = groupInfoData;\r\n            let groupsInfo = that._groupsInfo;\r\n            for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {\r\n                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\r\n                if (!groupInfo) {\r\n                    groupInfo = {\r\n                        key: path[pathIndex],\r\n                        offset: groupInfoData.offset,\r\n                        data: {\r\n                            offset: groupInfoData.offset,\r\n                            isExpanded: true,\r\n                            path: path.slice(0, pathIndex + 1)\r\n                        },\r\n                        children: []\r\n                    };\r\n                    const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);\r\n                    groupsInfo.splice(index, 0, groupInfo);\r\n                    groupsInfo.hash = groupsInfo.hash || {};\r\n                    groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo\r\n                }\r\n                if (pathIndex === path.length - 1) {\r\n                    groupInfo.data = groupInfoData;\r\n                    if (groupInfo.offset !== groupInfoData.offset) {\r\n                        that._updateGroupInfoOffsets(groupsInfo)\r\n                    }\r\n                }\r\n                groupsInfo = groupInfo.children\r\n            }\r\n        },\r\n        allowCollapseAll: () => true,\r\n        refresh(options) {\r\n            const that = this;\r\n            const {\r\n                storeLoadOptions: storeLoadOptions\r\n            } = options;\r\n            const groups = normalizeSortingInfo(storeLoadOptions.group || []);\r\n            const oldGroups = \"_group\" in that ? normalizeSortingInfo(that._group || []) : groups;\r\n            let groupsCount = Math.min(oldGroups.length, groups.length);\r\n            that._group = storeLoadOptions.group;\r\n            for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\r\n                if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {\r\n                    groupsCount = groupIndex;\r\n                    break\r\n                }\r\n            }\r\n            if (!groupsCount) {\r\n                that.reset()\r\n            } else {\r\n                cleanGroupsInfo(that._groupsInfo, 0, groupsCount)\r\n            }\r\n        },\r\n        handleDataLoading() {},\r\n        handleDataLoaded(options, callBase) {\r\n            callBase(options)\r\n        },\r\n        handleDataLoadedCore(options, callBase) {\r\n            callBase(options)\r\n        }\r\n    }\r\n}());\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}