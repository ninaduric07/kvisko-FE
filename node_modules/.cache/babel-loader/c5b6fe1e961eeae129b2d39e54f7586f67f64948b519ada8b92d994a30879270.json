{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const sortRowTree = params => {\n  const {\n    rowTree,\n    disableChildrenSorting,\n    sortRowList,\n    shouldRenderGroupBelowLeaves\n  } = params;\n  let sortedRows = [];\n  const sortedGroupedByParentRows = new Map();\n  const sortGroup = node => {\n    const shouldSortGroup = !!sortRowList && (!disableChildrenSorting || node.depth === -1);\n    let sortedRowIds;\n    if (shouldSortGroup) {\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childNode = rowTree[node.children[i]];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n        }\n      }\n      sortedRowIds = sortRowList(node.children.map(childId => rowTree[childId]));\n    } else if (shouldRenderGroupBelowLeaves) {\n      const childrenLeaves = [];\n      const childrenGroups = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childId = node.children[i];\n        const childNode = rowTree[childId];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n          childrenGroups.push(childId);\n        } else if (childNode.type === 'leaf') {\n          childrenLeaves.push(childId);\n        }\n      }\n      sortedRowIds = [...childrenLeaves, ...childrenGroups];\n    } else {\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childNode = rowTree[node.children[i]];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n        }\n      }\n      sortedRowIds = [...node.children];\n    }\n    if (node.footerId != null) {\n      sortedRowIds.push(node.footerId);\n    }\n    sortedGroupedByParentRows.set(node.id, sortedRowIds);\n  };\n  sortGroup(rowTree[GRID_ROOT_GROUP_ID]);\n\n  // Flatten the sorted lists to have children just after their parent\n  const insertRowListIntoSortedRows = (startIndex, rowList) => {\n    sortedRows = [...sortedRows.slice(0, startIndex), ...rowList, ...sortedRows.slice(startIndex)];\n    let treeSize = 0;\n    rowList.forEach(rowId => {\n      treeSize += 1;\n      const children = sortedGroupedByParentRows.get(rowId);\n      if (children != null && children.length) {\n        const subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(GRID_ROOT_GROUP_ID));\n  return sortedRows;\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","sortRowTree","params","rowTree","disableChildrenSorting","sortRowList","shouldRenderGroupBelowLeaves","sortedRows","sortedGroupedByParentRows","Map","sortGroup","node","shouldSortGroup","depth","sortedRowIds","i","children","length","childNode","type","map","childId","childrenLeaves","childrenGroups","push","footerId","set","id","insertRowListIntoSortedRows","startIndex","rowList","slice","treeSize","forEach","rowId","get","subTreeSize"],"sources":["C:/Users/ninad/OneDrive/Radna povrÅ¡ina/zavrsni/client/node_modules/@mui/x-data-grid-pro/utils/tree/sortRowTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const sortRowTree = params => {\n  const {\n    rowTree,\n    disableChildrenSorting,\n    sortRowList,\n    shouldRenderGroupBelowLeaves\n  } = params;\n  let sortedRows = [];\n  const sortedGroupedByParentRows = new Map();\n  const sortGroup = node => {\n    const shouldSortGroup = !!sortRowList && (!disableChildrenSorting || node.depth === -1);\n    let sortedRowIds;\n    if (shouldSortGroup) {\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childNode = rowTree[node.children[i]];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n        }\n      }\n      sortedRowIds = sortRowList(node.children.map(childId => rowTree[childId]));\n    } else if (shouldRenderGroupBelowLeaves) {\n      const childrenLeaves = [];\n      const childrenGroups = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childId = node.children[i];\n        const childNode = rowTree[childId];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n          childrenGroups.push(childId);\n        } else if (childNode.type === 'leaf') {\n          childrenLeaves.push(childId);\n        }\n      }\n      sortedRowIds = [...childrenLeaves, ...childrenGroups];\n    } else {\n      for (let i = 0; i < node.children.length; i += 1) {\n        const childNode = rowTree[node.children[i]];\n        if (childNode.type === 'group') {\n          sortGroup(childNode);\n        }\n      }\n      sortedRowIds = [...node.children];\n    }\n    if (node.footerId != null) {\n      sortedRowIds.push(node.footerId);\n    }\n    sortedGroupedByParentRows.set(node.id, sortedRowIds);\n  };\n  sortGroup(rowTree[GRID_ROOT_GROUP_ID]);\n\n  // Flatten the sorted lists to have children just after their parent\n  const insertRowListIntoSortedRows = (startIndex, rowList) => {\n    sortedRows = [...sortedRows.slice(0, startIndex), ...rowList, ...sortedRows.slice(startIndex)];\n    let treeSize = 0;\n    rowList.forEach(rowId => {\n      treeSize += 1;\n      const children = sortedGroupedByParentRows.get(rowId);\n      if (children != null && children.length) {\n        const subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(GRID_ROOT_GROUP_ID));\n  return sortedRows;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}