{"ast":null,"code":"var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n  var type = typeof o;\n  return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n  return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n  return typeof o === 'function';\n}\nfunction isString(o) {\n  return typeof o === 'string';\n}\nfunction isNumber(o) {\n  return typeof o === 'number';\n}\nfunction isNull(o) {\n  return o === null;\n}\nfunction isUndefined(o) {\n  return o === void 0;\n}\nfunction combineFrom(first, second) {\n  var out = {};\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n  if (second) {\n    for (var key$1 in second) {\n      out[key$1] = second[key$1];\n    }\n  }\n  return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n  if (isFunction(event)) {\n    return {\n      data: data,\n      event: event\n    };\n  }\n  return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n  return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n  return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n  parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n  if (isNull(nextNode)) {\n    appendChild(parentDOM, newNode);\n  } else {\n    parentDOM.insertBefore(newNode, nextNode);\n  }\n}\nfunction documentCreateElement(tag, isSVG) {\n  if (isSVG) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n  }\n  return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n  parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n  parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n  for (var i = 0; i < arrayFn.length; i++) {\n    arrayFn[i]();\n  }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n  var children = vNode.children;\n  if (flags & 4 /* ComponentClass */) {\n    return children.$LI;\n  }\n  if (flags & 8192 /* Fragment */) {\n    return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n  }\n  return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n  var flags;\n  while (vNode) {\n    flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n      return vNode.dom;\n    }\n    vNode = findChildVNode(vNode, startEdge, flags);\n  }\n  return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n  do {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n      removeChild(parentDOM, vNode.dom);\n      return;\n    }\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n      vNode = children.$LI;\n    }\n    if (flags & 8 /* ComponentFunction */) {\n      vNode = children;\n    }\n    if (flags & 8192 /* Fragment */) {\n      if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          removeVNodeDOM(children[i], parentDOM);\n        }\n        return;\n      }\n    }\n  } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n  do {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n      insertOrAppend(parentDOM, vNode.dom, nextNode);\n      return;\n    }\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n      vNode = children.$LI;\n    }\n    if (flags & 8 /* ComponentFunction */) {\n      vNode = children;\n    }\n    if (flags & 8192 /* Fragment */) {\n      if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          moveVNodeDOM(children[i], parentDOM, nextNode);\n        }\n        return;\n      }\n    }\n  } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n  if (instance.constructor.getDerivedStateFromProps) {\n    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n  }\n  return state;\n}\nvar renderCheck = {\n  v: false\n};\nvar options = {\n  componentComparator: null,\n  createVNode: null,\n  renderComplete: null\n};\nfunction setTextContent(dom, children) {\n  dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;\n}\nfunction mergeUnsetProperties(to, from) {\n  for (var propName in from) {\n    if (isUndefined(to[propName])) {\n      to[propName] = from[propName];\n    }\n  }\n  return to;\n}\nfunction safeCall1(method, arg1) {\n  return !!isFunction(method) && (method(arg1), true);\n}\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n  this.childFlags = childFlags;\n  this.children = children;\n  this.className = className;\n  this.dom = null;\n  this.flags = flags;\n  this.key = key === void 0 ? null : key;\n  this.props = props === void 0 ? null : props;\n  this.ref = ref === void 0 ? null : ref;\n  this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n  var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n  var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n  if (childFlag === 0 /* UnknownChildren */) {\n    normalizeChildren(vNode, vNode.children);\n  }\n  return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n  if (flags & 4 /* ComponentClass */) {\n    return ref;\n  }\n  var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n  if (isNullOrUndef(defaultHooks)) {\n    return ref;\n  }\n  if (isNullOrUndef(ref)) {\n    return defaultHooks;\n  }\n  return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n  // set default props\n  var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n  if (isNullOrUndef(defaultProps)) {\n    return props;\n  }\n  if (isNullOrUndef(props)) {\n    return combineFrom(defaultProps, null);\n  }\n  return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n  if (flags & 12 /* ComponentKnown */) {\n    return flags;\n  }\n  if (type.prototype && type.prototype.render) {\n    return 4 /* ComponentClass */;\n  }\n\n  if (type.render) {\n    return 32776 /* ForwardRefComponent */;\n  }\n\n  return 8 /* ComponentFunction */;\n}\n\nfunction createComponentVNode(flags, type, props, key, ref) {\n  flags = resolveComponentFlags(flags, type);\n  var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n  return vNode;\n}\nfunction createTextVNode(text, key) {\n  return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n  var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n  switch (fragment.childFlags) {\n    case 1 /* HasInvalidChildren */:\n      fragment.children = createVoidVNode();\n      fragment.childFlags = 2 /* HasVNodeChildren */;\n      break;\n    case 16 /* HasTextChildren */:\n      fragment.children = [createTextVNode(children)];\n      fragment.childFlags = 4 /* HasNonKeyedChildren */;\n      break;\n  }\n  return fragment;\n}\nfunction normalizeProps(vNode) {\n  var props = vNode.props;\n  if (props) {\n    var flags = vNode.flags;\n    if (flags & 481 /* Element */) {\n      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n        normalizeChildren(vNode, props.children);\n      }\n      if (props.className !== void 0) {\n        if (isNullOrUndef(vNode.className)) {\n          vNode.className = props.className || null;\n        }\n        props.className = undefined;\n      }\n    }\n    if (props.key !== void 0) {\n      vNode.key = props.key;\n      props.key = undefined;\n    }\n    if (props.ref !== void 0) {\n      if (flags & 8 /* ComponentFunction */) {\n        vNode.ref = combineFrom(vNode.ref, props.ref);\n      } else {\n        vNode.ref = props.ref;\n      }\n      props.ref = undefined;\n    }\n  }\n  return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n  var oldChildren = vNodeToClone.children;\n  var childFlags = vNodeToClone.childFlags;\n  return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n  var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n  var props = vNodeToClone.props;\n  if (flags & 14 /* Component */) {\n    if (!isNull(props)) {\n      var propsToClone = props;\n      props = {};\n      for (var key in propsToClone) {\n        props[key] = propsToClone[key];\n      }\n    }\n  }\n  if ((flags & 8192 /* Fragment */) === 0) {\n    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n  }\n  return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n  return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n  var normalizedRoot = normalizeRoot(children);\n  return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n  for (var len = nodes.length; index < len; index++) {\n    var n = nodes[index];\n    if (!isInvalid(n)) {\n      var newKey = currentKey + keyPrefix + index;\n      if (isArray(n)) {\n        _normalizeVNodes(n, result, 0, newKey);\n      } else {\n        if (isStringOrNumber(n)) {\n          n = createTextVNode(n, newKey);\n        } else {\n          var oldKey = n.key;\n          var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n          if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n            n = directClone(n);\n          }\n          n.flags |= 65536 /* Normalized */;\n          if (!isPrefixedKey) {\n            if (isNull(oldKey)) {\n              n.key = newKey;\n            } else {\n              n.key = currentKey + oldKey;\n            }\n          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n            n.key = currentKey + oldKey;\n          }\n        }\n        result.push(n);\n      }\n    }\n  }\n}\nfunction getFlagsForElementVnode(type) {\n  switch (type) {\n    case 'svg':\n      return 32 /* SvgElement */;\n    case 'input':\n      return 64 /* InputElement */;\n    case 'select':\n      return 256 /* SelectElement */;\n    case 'textarea':\n      return 128 /* TextareaElement */;\n    case Fragment:\n      return 8192 /* Fragment */;\n    default:\n      return 1 /* HtmlElement */;\n  }\n}\n\nfunction normalizeChildren(vNode, children) {\n  var newChildren;\n  var newChildFlags = 1 /* HasInvalidChildren */;\n  // Don't change children to match strict equal (===) true in patching\n  if (isInvalid(children)) {\n    newChildren = children;\n  } else if (isStringOrNumber(children)) {\n    newChildFlags = 16 /* HasTextChildren */;\n    newChildren = children;\n  } else if (isArray(children)) {\n    var len = children.length;\n    for (var i = 0; i < len; ++i) {\n      var n = children[i];\n      if (isInvalid(n) || isArray(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        _normalizeVNodes(children, newChildren, i, '');\n        break;\n      } else if (isStringOrNumber(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        newChildren.push(createTextVNode(n, keyPrefix + i));\n      } else {\n        var key = n.key;\n        var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n        var isNullKey = isNull(key);\n        var isPrefixed = isString(key) && key[0] === keyPrefix;\n        if (needsCloning || isNullKey || isPrefixed) {\n          newChildren = newChildren || children.slice(0, i);\n          if (needsCloning || isPrefixed) {\n            n = directClone(n);\n          }\n          if (isNullKey || isPrefixed) {\n            n.key = keyPrefix + i;\n          }\n          newChildren.push(n);\n        } else if (newChildren) {\n          newChildren.push(n);\n        }\n        n.flags |= 65536 /* Normalized */;\n      }\n    }\n\n    newChildren = newChildren || children;\n    if (newChildren.length === 0) {\n      newChildFlags = 1 /* HasInvalidChildren */;\n    } else {\n      newChildFlags = 8 /* HasKeyedChildren */;\n    }\n  } else {\n    newChildren = children;\n    newChildren.flags |= 65536 /* Normalized */;\n    if (children.flags & 81920 /* InUseOrNormalized */) {\n      newChildren = directClone(children);\n    }\n    newChildFlags = 2 /* HasVNodeChildren */;\n  }\n\n  vNode.children = newChildren;\n  vNode.childFlags = newChildFlags;\n  return vNode;\n}\nfunction normalizeRoot(input) {\n  if (isInvalid(input) || isStringOrNumber(input)) {\n    return createTextVNode(input, null);\n  }\n  if (isArray(input)) {\n    return createFragment(input, 0 /* UnknownChildren */, null);\n  }\n  return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n  'xlink:actuate': xlinkNS,\n  'xlink:arcrole': xlinkNS,\n  'xlink:href': xlinkNS,\n  'xlink:role': xlinkNS,\n  'xlink:show': xlinkNS,\n  'xlink:title': xlinkNS,\n  'xlink:type': xlinkNS,\n  'xml:base': xmlNS,\n  'xml:lang': xmlNS,\n  'xml:space': xmlNS\n};\nfunction getDelegatedEventObject(v) {\n  return {\n    onClick: v,\n    onDblClick: v,\n    onFocusIn: v,\n    onFocusOut: v,\n    onKeyDown: v,\n    onKeyPress: v,\n    onKeyUp: v,\n    onMouseDown: v,\n    onMouseMove: v,\n    onMouseUp: v,\n    onTouchEnd: v,\n    onTouchMove: v,\n    onTouchStart: v\n  };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n  if (!eventsObject) {\n    eventsObject = dom.$EV = getDelegatedEventObject(null);\n  }\n  if (!eventsObject[name]) {\n    if (++attachedEventCounts[name] === 1) {\n      attachedEvents[name] = attachEventToDocument(name);\n    }\n  }\n  return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n  if (eventsObject && eventsObject[name]) {\n    if (--attachedEventCounts[name] === 0) {\n      document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n      attachedEvents[name] = null;\n    }\n    eventsObject[name] = null;\n  }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n  if (isFunction(nextEvent)) {\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else if (isLinkEventObject(nextEvent)) {\n    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n      return;\n    }\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else {\n    unmountSyntheticEvent(name, dom);\n  }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n  return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n  var dom = getTargetNode(event);\n  do {\n    // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n    // because the event listener is on document.body\n    // Don't process clicks on disabled elements\n    if (isClick && dom.disabled) {\n      return;\n    }\n    var eventsObject = dom.$EV;\n    if (eventsObject) {\n      var currentEvent = eventsObject[name];\n      if (currentEvent) {\n        // linkEvent object\n        eventData.dom = dom;\n        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n        if (event.cancelBubble) {\n          return;\n        }\n      }\n    }\n    dom = dom.parentNode;\n  } while (!isNull(dom));\n}\nfunction stopPropagation() {\n  this.cancelBubble = true;\n  if (!this.immediatePropagationStopped) {\n    this.stopImmediatePropagation();\n  }\n}\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n  // Event data needs to be object to save reference to currentTarget getter\n  var eventData = {\n    dom: document\n  };\n  event.isDefaultPrevented = isDefaultPrevented;\n  event.isPropagationStopped = isPropagationStopped;\n  event.stopPropagation = stopPropagation;\n  Object.defineProperty(event, 'currentTarget', {\n    configurable: true,\n    get: function get() {\n      return eventData.dom;\n    }\n  });\n  return eventData;\n}\nfunction rootClickEvent(name) {\n  return function (event) {\n    if (event.button !== 0) {\n      // Firefox incorrectly triggers click event for mid/right mouse buttons.\n      // This bug has been active for 17 years.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n      event.stopPropagation();\n      return;\n    }\n    dispatchEvents(event, true, name, extendEventProperties(event));\n  };\n}\nfunction rootEvent(name) {\n  return function (event) {\n    dispatchEvents(event, false, name, extendEventProperties(event));\n  };\n}\nfunction attachEventToDocument(name) {\n  var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n  document.addEventListener(normalizeEventName(name), attachedEvent);\n  return attachedEvent;\n}\nfunction isSameInnerHTML(dom, innerHTML) {\n  var tempdom = document.createElement('i');\n  tempdom.innerHTML = innerHTML;\n  return tempdom.innerHTML === dom.innerHTML;\n}\nfunction triggerEventListener(props, methodName, e) {\n  if (props[methodName]) {\n    var listener = props[methodName];\n    if (listener.event) {\n      listener.event(listener.data, e);\n    } else {\n      listener(e);\n    }\n  } else {\n    var nativeListenerName = methodName.toLowerCase();\n    if (props[nativeListenerName]) {\n      props[nativeListenerName](e);\n    }\n  }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n  var fnMethod = function (e) {\n    var vNode = this.$V;\n    // If vNode is gone by the time event fires, no-op\n    if (!vNode) {\n      return;\n    }\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (isString(methodName)) {\n      triggerEventListener(props, methodName, e);\n    } else {\n      for (var i = 0; i < methodName.length; ++i) {\n        triggerEventListener(props, methodName[i], e);\n      }\n    }\n    if (isFunction(applyValue)) {\n      var newVNode = this.$V;\n      var newProps = newVNode.props || EMPTY_OBJ;\n      applyValue(newProps, dom, false, newVNode);\n    }\n  };\n  Object.defineProperty(fnMethod, 'wrapped', {\n    configurable: false,\n    enumerable: false,\n    value: true,\n    writable: false\n  });\n  return fnMethod;\n}\nfunction attachEvent(dom, eventName, handler) {\n  var previousKey = \"$\" + eventName;\n  var previousArgs = dom[previousKey];\n  if (previousArgs) {\n    if (previousArgs[1].wrapped) {\n      return;\n    }\n    dom.removeEventListener(previousArgs[0], previousArgs[1]);\n    dom[previousKey] = null;\n  }\n  if (isFunction(handler)) {\n    dom.addEventListener(eventName, handler);\n    dom[previousKey] = [eventName, handler];\n  }\n}\nfunction isCheckedType(type) {\n  return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n  event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n  if (isCheckedType(nextPropsOrEmpty.type)) {\n    attachEvent(dom, 'change', wrappedOnChange);\n    attachEvent(dom, 'click', emptywrapper);\n  } else {\n    attachEvent(dom, 'input', onTextInputChange);\n  }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n  var type = nextPropsOrEmpty.type;\n  var value = nextPropsOrEmpty.value;\n  var checked = nextPropsOrEmpty.checked;\n  var multiple = nextPropsOrEmpty.multiple;\n  var defaultValue = nextPropsOrEmpty.defaultValue;\n  var hasValue = !isNullOrUndef(value);\n  if (type && type !== dom.type) {\n    dom.setAttribute('type', type);\n  }\n  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n    dom.multiple = multiple;\n  }\n  if (!isNullOrUndef(defaultValue) && !hasValue) {\n    dom.defaultValue = defaultValue + '';\n  }\n  if (isCheckedType(type)) {\n    if (hasValue) {\n      dom.value = value;\n    }\n    if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  } else {\n    if (hasValue && dom.value !== value) {\n      dom.defaultValue = value;\n      dom.value = value;\n    } else if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  }\n}\nfunction updateChildOptions(vNode, value) {\n  if (vNode.type === 'option') {\n    updateChildOption(vNode, value);\n  } else {\n    var children = vNode.children;\n    var flags = vNode.flags;\n    if (flags & 4 /* ComponentClass */) {\n      updateChildOptions(children.$LI, value);\n    } else if (flags & 8 /* ComponentFunction */) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags & 12 /* MultipleChildren */) {\n      for (var i = 0, len = children.length; i < len; ++i) {\n        updateChildOptions(children[i], value);\n      }\n    }\n  }\n}\nfunction updateChildOption(vNode, value) {\n  var props = vNode.props || EMPTY_OBJ;\n  var dom = vNode.dom;\n  // we do this as multiple may have changed\n  dom.value = props.value;\n  if (props.value === value || isArray(value) && value.indexOf(props.value) !== -1) {\n    dom.selected = true;\n  } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n    dom.selected = props.selected || false;\n  }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n  attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n    dom.multiple = multiplePropInBoolean;\n  }\n  var index = nextPropsOrEmpty.selectedIndex;\n  if (index === -1) {\n    dom.selectedIndex = -1;\n  }\n  var childFlags = vNode.childFlags;\n  if (childFlags !== 1 /* HasInvalidChildren */) {\n    var value = nextPropsOrEmpty.value;\n    if (isNumber(index) && index > -1 && dom.options[index]) {\n      value = dom.options[index].value;\n    }\n    if (mounting && isNullOrUndef(value)) {\n      value = nextPropsOrEmpty.defaultValue;\n    }\n    updateChildOptions(vNode, value);\n  }\n}\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n  attachEvent(dom, 'input', onTextareaInputChange);\n  if (nextPropsOrEmpty.onChange) {\n    attachEvent(dom, 'change', wrappedOnChange$1);\n  }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n  var value = nextPropsOrEmpty.value;\n  var domValue = dom.value;\n  if (isNullOrUndef(value)) {\n    if (mounting) {\n      var defaultValue = nextPropsOrEmpty.defaultValue;\n      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n        dom.defaultValue = defaultValue;\n        dom.value = defaultValue;\n      }\n    }\n  } else if (domValue !== value) {\n    /* There is value so keep it controlled */\n    dom.defaultValue = value;\n    dom.value = value;\n  }\n}\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n  if (flags & 64 /* InputElement */) {\n    applyValueInput(nextPropsOrEmpty, dom);\n  } else if (flags & 256 /* SelectElement */) {\n    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n  } else if (flags & 128 /* TextareaElement */) {\n    applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n  }\n  if (isControlled) {\n    dom.$V = vNode;\n  }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n  if (flags & 64 /* InputElement */) {\n    inputEvents(dom, nextPropsOrEmpty);\n  } else if (flags & 256 /* SelectElement */) {\n    selectEvents(dom);\n  } else if (flags & 128 /* TextareaElement */) {\n    textAreaEvents(dom, nextPropsOrEmpty);\n  }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\nfunction createRef() {\n  return {\n    current: null\n  };\n}\nfunction forwardRef(render) {\n  // @ts-ignore\n  return {\n    render: render\n  };\n}\nfunction unmountRef(ref) {\n  if (ref) {\n    if (!safeCall1(ref, null) && ref.current) {\n      ref.current = null;\n    }\n  }\n}\nfunction mountRef(ref, value, lifecycle) {\n  if (ref && (isFunction(ref) || ref.current !== void 0)) {\n    lifecycle.push(function () {\n      if (!safeCall1(ref, value) && ref.current !== void 0) {\n        ref.current = value;\n      }\n    });\n  }\n}\nfunction remove(vNode, parentDOM) {\n  unmount(vNode);\n  removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n  var flags = vNode.flags;\n  var children = vNode.children;\n  var ref;\n  if (flags & 481 /* Element */) {\n    ref = vNode.ref;\n    var props = vNode.props;\n    unmountRef(ref);\n    var childFlags = vNode.childFlags;\n    if (!isNull(props)) {\n      var keys = Object.keys(props);\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i];\n        if (syntheticEvents[key]) {\n          unmountSyntheticEvent(key, vNode.dom);\n        }\n      }\n    }\n    if (childFlags & 12 /* MultipleChildren */) {\n      unmountAllChildren(children);\n    } else if (childFlags === 2 /* HasVNodeChildren */) {\n      unmount(children);\n    }\n  } else if (children) {\n    if (flags & 4 /* ComponentClass */) {\n      if (isFunction(children.componentWillUnmount)) {\n        children.componentWillUnmount();\n      }\n      unmountRef(vNode.ref);\n      children.$UN = true;\n      unmount(children.$LI);\n    } else if (flags & 8 /* ComponentFunction */) {\n      ref = vNode.ref;\n      if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n      }\n      unmount(children);\n    } else if (flags & 1024 /* Portal */) {\n      remove(children, vNode.ref);\n    } else if (flags & 8192 /* Fragment */) {\n      if (vNode.childFlags & 12 /* MultipleChildren */) {\n        unmountAllChildren(children);\n      }\n    }\n  }\n}\nfunction unmountAllChildren(children) {\n  for (var i = 0, len = children.length; i < len; ++i) {\n    unmount(children[i]);\n  }\n}\nfunction clearDOM(dom) {\n  // Optimization for clearing dom\n  dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n  unmountAllChildren(children);\n  if (vNode.flags & 8192 /* Fragment */) {\n    removeVNodeDOM(vNode, dom);\n  } else {\n    clearDOM(dom);\n  }\n}\nfunction wrapLinkEvent(nextValue) {\n  // This variable makes sure there is no \"this\" context in callback\n  var ev = nextValue.event;\n  return function (e) {\n    ev(nextValue.data, e);\n  };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n  if (isLinkEventObject(nextValue)) {\n    if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n      return;\n    }\n    nextValue = wrapLinkEvent(nextValue);\n  }\n  attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n  if (isNullOrUndef(nextAttrValue)) {\n    dom.removeAttribute('style');\n    return;\n  }\n  var domStyle = dom.style;\n  var style;\n  var value;\n  if (isString(nextAttrValue)) {\n    domStyle.cssText = nextAttrValue;\n    return;\n  }\n  if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n    for (style in nextAttrValue) {\n      // do not add a hasOwnProperty check here, it affects performance\n      value = nextAttrValue[style];\n      if (value !== lastAttrValue[style]) {\n        domStyle.setProperty(style, value);\n      }\n    }\n    for (style in lastAttrValue) {\n      if (isNullOrUndef(nextAttrValue[style])) {\n        domStyle.removeProperty(style);\n      }\n    }\n  } else {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n      domStyle.setProperty(style, value);\n    }\n  }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n  var lastHtml = lastValue && lastValue.__html || '';\n  var nextHtml = nextValue && nextValue.__html || '';\n  if (lastHtml !== nextHtml) {\n    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n      if (!isNull(lastVNode)) {\n        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n          unmountAllChildren(lastVNode.children);\n        } else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n          unmount(lastVNode.children);\n        }\n        lastVNode.children = null;\n        lastVNode.childFlags = 1 /* HasInvalidChildren */;\n      }\n\n      dom.innerHTML = nextHtml;\n    }\n  }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n  switch (prop) {\n    case 'children':\n    case 'childrenType':\n    case 'className':\n    case 'defaultValue':\n    case 'key':\n    case 'multiple':\n    case 'ref':\n    case 'selectedIndex':\n      break;\n    case 'autoFocus':\n      dom.autofocus = !!nextValue;\n      break;\n    case 'allowfullscreen':\n    case 'autoplay':\n    case 'capture':\n    case 'checked':\n    case 'controls':\n    case 'default':\n    case 'disabled':\n    case 'hidden':\n    case 'indeterminate':\n    case 'loop':\n    case 'muted':\n    case 'novalidate':\n    case 'open':\n    case 'readOnly':\n    case 'required':\n    case 'reversed':\n    case 'scoped':\n    case 'seamless':\n    case 'selected':\n      dom[prop] = !!nextValue;\n      break;\n    case 'defaultChecked':\n    case 'value':\n    case 'volume':\n      if (hasControlledValue && prop === 'value') {\n        break;\n      }\n      var value = isNullOrUndef(nextValue) ? '' : nextValue;\n      if (dom[prop] !== value) {\n        dom[prop] = value;\n      }\n      break;\n    case 'style':\n      patchStyle(lastValue, nextValue, dom);\n      break;\n    case 'dangerouslySetInnerHTML':\n      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n      break;\n    default:\n      if (syntheticEvents[prop]) {\n        handleSyntheticEvent(prop, lastValue, nextValue, dom);\n      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n        patchEvent(prop, lastValue, nextValue, dom);\n      } else if (isNullOrUndef(nextValue)) {\n        dom.removeAttribute(prop);\n      } else if (isSVG && namespaces[prop]) {\n        // We optimize for isSVG being false\n        // If we end up in this path we can read property again\n        dom.setAttributeNS(namespaces[prop], prop, nextValue);\n      } else {\n        dom.setAttribute(prop, nextValue);\n      }\n      break;\n  }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n  var hasControlledValue = false;\n  var isFormElement = (flags & 448 /* FormElement */) > 0;\n  if (isFormElement) {\n    hasControlledValue = isControlledFormElement(props);\n    if (hasControlledValue) {\n      addFormElementEventHandlers(flags, dom, props);\n    }\n  }\n  for (var prop in props) {\n    // do not add a hasOwnProperty check here, it affects performance\n    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n  }\n  if (isFormElement) {\n    processElement(flags, vNode, dom, props, true, hasControlledValue);\n  }\n}\nfunction renderNewInput(instance, props, context) {\n  var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n  var childContext = context;\n  if (isFunction(instance.getChildContext)) {\n    childContext = combineFrom(context, instance.getChildContext());\n  }\n  instance.$CX = childContext;\n  return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n  var instance = new Component(props, context);\n  var usesNewAPI = instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);\n  instance.$SVG = isSVG;\n  instance.$L = lifecycle;\n  vNode.children = instance;\n  instance.$BS = false;\n  instance.context = context;\n  if (instance.props === EMPTY_OBJ) {\n    instance.props = props;\n  }\n  if (!usesNewAPI) {\n    if (isFunction(instance.componentWillMount)) {\n      instance.$BR = true;\n      instance.componentWillMount();\n      var pending = instance.$PS;\n      if (!isNull(pending)) {\n        var state = instance.state;\n        if (isNull(state)) {\n          instance.state = pending;\n        } else {\n          for (var key in pending) {\n            state[key] = pending[key];\n          }\n        }\n        instance.$PS = null;\n      }\n      instance.$BR = false;\n    }\n  } else {\n    instance.state = createDerivedState(instance, props, instance.state);\n  }\n  instance.$LI = renderNewInput(instance, props, context);\n  return instance;\n}\nfunction renderFunctionalComponent(vNode, context) {\n  var props = vNode.props || EMPTY_OBJ;\n  return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags |= 16384 /* InUse */;\n  if (flags & 481 /* Element */) {\n    mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 4 /* ComponentClass */) {\n    mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 8 /* ComponentFunction */) {\n    mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(vNode, lifecycle);\n  } else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n    mountText(vNode, parentDOM, nextNode);\n  } else if (flags & 8192 /* Fragment */) {\n    mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n  } else if (flags & 1024 /* Portal */) {\n    mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n  } else ;\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n  mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n  var placeHolderVNode = createVoidVNode();\n  mountText(placeHolderVNode, parentDOM, nextNode);\n  vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n  var children = vNode.children;\n  var childFlags = vNode.childFlags;\n  // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n  if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n    childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n    children = vNode.children = createVoidVNode();\n  }\n  if (childFlags === 2 /* HasVNodeChildren */) {\n    mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else {\n    mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n  var dom = vNode.dom = document.createTextNode(vNode.children);\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags;\n  var props = vNode.props;\n  var className = vNode.className;\n  var childFlags = vNode.childFlags;\n  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32 /* SvgElement */) > 0);\n  var children = vNode.children;\n  if (!isNullOrUndef(className) && className !== '') {\n    if (isSVG) {\n      dom.setAttribute('class', className);\n    } else {\n      dom.className = className;\n    }\n  }\n  if (childFlags === 16 /* HasTextChildren */) {\n    setTextContent(dom, children);\n  } else if (childFlags !== 1 /* HasInvalidChildren */) {\n    var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n    if (childFlags === 2 /* HasVNodeChildren */) {\n      if (children.flags & 16384 /* InUse */) {\n        vNode.children = children = directClone(children);\n      }\n      mount(children, dom, context, childrenIsSVG, null, lifecycle);\n    } else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n      mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n    }\n  }\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n  if (!isNull(props)) {\n    mountProps(vNode, flags, props, dom, isSVG);\n  }\n  mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    if (child.flags & 16384 /* InUse */) {\n      children[i] = child = directClone(child);\n    }\n    mount(child, dom, context, isSVG, nextNode, lifecycle);\n  }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context)), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n  return function () {\n    instance.componentDidMount();\n  };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n  mountRef(ref, instance, lifecycle);\n  if (isFunction(instance.componentDidMount)) {\n    lifecycle.push(createClassMountCallback(instance));\n  }\n}\nfunction createOnMountCallback(ref, vNode) {\n  return function () {\n    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n  };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n  var ref = vNode.ref;\n  if (!isNullOrUndef(ref)) {\n    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n    if (isFunction(ref.onComponentDidMount)) {\n      lifecycle.push(createOnMountCallback(ref, vNode));\n    }\n  }\n}\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastVNode);\n  if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n    mount(nextVNode, null, context, isSVG, null, lifecycle);\n    // Single DOM operation, when we have dom references available\n    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n  } else {\n    mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n    removeVNodeDOM(lastVNode, parentDOM);\n  }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var nextFlags = nextVNode.flags |= 16384 /* InUse */;\n  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n    if (lastVNode.flags & 16384 /* InUse */) {\n      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    } else {\n      // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n      mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (nextFlags & 481 /* Element */) {\n    patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n  } else if (nextFlags & 4 /* ComponentClass */) {\n    patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 8 /* ComponentFunction */) {\n    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 16 /* Text */) {\n    patchText(lastVNode, nextVNode);\n  } else if (nextFlags & 512 /* Void */) {\n    nextVNode.dom = lastVNode.dom;\n  } else if (nextFlags & 8192 /* Fragment */) {\n    patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n  } else {\n    patchPortal(lastVNode, nextVNode, context, lifecycle);\n  }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n  if (lastChildren !== nextChildren) {\n    if (lastChildren !== '') {\n      parentDOM.firstChild.nodeValue = nextChildren;\n    } else {\n      setTextContent(parentDOM, nextChildren);\n    }\n  }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n  if (dom.textContent !== nextChildren) {\n    dom.textContent = nextChildren;\n  }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  var lastChildren = lastVNode.children;\n  var nextChildren = nextVNode.children;\n  var lastChildFlags = lastVNode.childFlags;\n  var nextChildFlags = nextVNode.childFlags;\n  var nextNode = null;\n  // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n  if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n    nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n    nextChildren = nextVNode.children = createVoidVNode();\n  }\n  var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n  if (lastChildFlags & 12 /* MultipleChildren */) {\n    var lastLen = lastChildren.length;\n    // We need to know Fragment's edge node when\n    if (\n    // It uses keyed algorithm\n    lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */ ||\n    // It transforms from many to single\n    nextIsSingle ||\n    // It will append more nodes\n    !nextIsSingle && nextChildren.length > lastLen) {\n      // When fragment has multiple children there is always at least one vNode\n      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n    }\n  }\n  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n  var lastContainer = lastVNode.ref;\n  var nextContainer = nextVNode.ref;\n  var nextChildren = nextVNode.children;\n  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n  nextVNode.dom = lastVNode.dom;\n  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n    var node = nextChildren.dom;\n    removeChild(lastContainer, node);\n    appendChild(nextContainer, node);\n  }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n  var dom = nextVNode.dom = lastVNode.dom;\n  var lastProps = lastVNode.props;\n  var nextProps = nextVNode.props;\n  var isFormElement = false;\n  var hasControlledValue = false;\n  var nextPropsOrEmpty;\n  isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n  // inlined patchProps  -- starts --\n  if (lastProps !== nextProps) {\n    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n    nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n    if (nextPropsOrEmpty !== EMPTY_OBJ) {\n      isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n      if (isFormElement) {\n        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n      }\n      for (var prop in nextPropsOrEmpty) {\n        var lastValue = lastPropsOrEmpty[prop];\n        var nextValue = nextPropsOrEmpty[prop];\n        if (lastValue !== nextValue) {\n          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n    if (lastPropsOrEmpty !== EMPTY_OBJ) {\n      for (var prop$1 in lastPropsOrEmpty) {\n        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n  }\n  var nextChildren = nextVNode.children;\n  var nextClassName = nextVNode.className;\n  // inlined patchProps  -- ends --\n  if (lastVNode.className !== nextClassName) {\n    if (isNullOrUndef(nextClassName)) {\n      dom.removeAttribute('class');\n    } else if (isSVG) {\n      dom.setAttribute('class', nextClassName);\n    } else {\n      dom.className = nextClassName;\n    }\n  }\n  if (nextFlags & 4096 /* ContentEditable */) {\n    patchContentEditableChildren(dom, nextChildren);\n  } else {\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n  }\n  if (isFormElement) {\n    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n  }\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, dom, lifecycle);\n  }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastChildren);\n  mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n  removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n  switch (lastChildFlags) {\n    case 2 /* HasVNodeChildren */:\n      switch (nextChildFlags) {\n        case 2 /* HasVNodeChildren */:\n          patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n        case 1 /* HasInvalidChildren */:\n          remove(lastChildren, parentDOM);\n          break;\n        case 16 /* HasTextChildren */:\n          unmount(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n        default:\n          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n          break;\n      }\n      break;\n    case 1 /* HasInvalidChildren */:\n      switch (nextChildFlags) {\n        case 2 /* HasVNodeChildren */:\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n        case 1 /* HasInvalidChildren */:\n          break;\n        case 16 /* HasTextChildren */:\n          setTextContent(parentDOM, nextChildren);\n          break;\n        default:\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n      break;\n    case 16 /* HasTextChildren */:\n      switch (nextChildFlags) {\n        case 16 /* HasTextChildren */:\n          patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n          break;\n        case 2 /* HasVNodeChildren */:\n          clearDOM(parentDOM);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n        case 1 /* HasInvalidChildren */:\n          clearDOM(parentDOM);\n          break;\n        default:\n          clearDOM(parentDOM);\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n      break;\n    default:\n      switch (nextChildFlags) {\n        case 16 /* HasTextChildren */:\n          unmountAllChildren(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n        case 2 /* HasVNodeChildren */:\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n        case 1 /* HasInvalidChildren */:\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          break;\n        default:\n          var lastLength = lastChildren.length | 0;\n          var nextLength = nextChildren.length | 0;\n          // Fast path's for both algorithms\n          if (lastLength === 0) {\n            if (nextLength > 0) {\n              mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n            }\n          } else if (nextLength === 0) {\n            removeAllChildren(parentDOM, parentVNode, lastChildren);\n          } else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n          } else {\n            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n          }\n          break;\n      }\n      break;\n  }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n  lifecycle.push(function () {\n    instance.componentDidUpdate(lastProps, lastState, snapshot);\n  });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n  var lastState = instance.state;\n  var lastProps = instance.props;\n  var usesNewAPI = Boolean(instance.$N);\n  var hasSCU = isFunction(instance.shouldComponentUpdate);\n  if (usesNewAPI) {\n    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n  }\n  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {\n    if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n      instance.componentWillUpdate(nextProps, nextState, context);\n    }\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n    var snapshot = null;\n    var nextInput = renderNewInput(instance, nextProps, context);\n    if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n    }\n    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    // Dont update Last input, until patch has been succesfully executed\n    instance.$LI = nextInput;\n    if (isFunction(instance.componentDidUpdate)) {\n      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n    }\n  } else {\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n  }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = nextVNode.children = lastVNode.children;\n  // If Component has crashed, ignore it to stay functional\n  if (isNull(instance)) {\n    return;\n  }\n  instance.$L = lifecycle;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  var nextState = instance.state;\n  if (!instance.$N) {\n    if (isFunction(instance.componentWillReceiveProps)) {\n      instance.$BR = true;\n      instance.componentWillReceiveProps(nextProps, context);\n      // If instance component was removed during its own update do nothing.\n      if (instance.$UN) {\n        return;\n      }\n      instance.$BR = false;\n    }\n    if (!isNull(instance.$PS)) {\n      nextState = combineFrom(nextState, instance.$PS);\n      instance.$PS = null;\n    }\n  }\n  updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, instance, lifecycle);\n  }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var shouldUpdate = true;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastProps = lastVNode.props;\n  var nextHooksDefined = !isNullOrUndef(nextRef);\n  var lastInput = lastVNode.children;\n  if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n  }\n  if (shouldUpdate !== false) {\n    if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n      nextRef.onComponentWillUpdate(lastProps, nextProps);\n    }\n    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n    patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n    nextVNode.children = nextInput;\n    if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n      nextRef.onComponentDidUpdate(lastProps, nextProps);\n    }\n  } else {\n    nextVNode.children = lastInput;\n  }\n}\nfunction patchText(lastVNode, nextVNode) {\n  var nextText = nextVNode.children;\n  var dom = nextVNode.dom = lastVNode.dom;\n  if (nextText !== lastVNode.children) {\n    dom.nodeValue = nextText;\n  }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n  var i = 0;\n  var nextChild;\n  var lastChild;\n  for (; i < commonLength; ++i) {\n    nextChild = nextChildren[i];\n    lastChild = lastChildren[i];\n    if (nextChild.flags & 16384 /* InUse */) {\n      nextChild = nextChildren[i] = directClone(nextChild);\n    }\n    patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n    lastChildren[i] = nextChild;\n  }\n  if (lastChildrenLength < nextChildrenLength) {\n    for (i = commonLength; i < nextChildrenLength; ++i) {\n      nextChild = nextChildren[i];\n      if (nextChild.flags & 16384 /* InUse */) {\n        nextChild = nextChildren[i] = directClone(nextChild);\n      }\n      mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (lastChildrenLength > nextChildrenLength) {\n    for (i = commonLength; i < lastChildrenLength; ++i) {\n      remove(lastChildren[i], dom);\n    }\n  }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n  var aEnd = aLength - 1;\n  var bEnd = bLength - 1;\n  var j = 0;\n  var aNode = a[j];\n  var bNode = b[j];\n  var nextPos;\n  var nextNode;\n  // Step 1\n  // tslint:disable-next-line\n  outer: {\n    // Sync nodes with the same key at the beginning.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384 /* InUse */) {\n        b[j] = bNode = directClone(bNode);\n      }\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[j] = bNode;\n      ++j;\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n      aNode = a[j];\n      bNode = b[j];\n    }\n    aNode = a[aEnd];\n    bNode = b[bEnd];\n    // Sync nodes with the same key at the end.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384 /* InUse */) {\n        b[bEnd] = bNode = directClone(bNode);\n      }\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[aEnd] = bNode;\n      aEnd--;\n      bEnd--;\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n      aNode = a[aEnd];\n      bNode = b[bEnd];\n    }\n  }\n  if (j > aEnd) {\n    if (j <= bEnd) {\n      nextPos = bEnd + 1;\n      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n      while (j <= bEnd) {\n        bNode = b[j];\n        if (bNode.flags & 16384 /* InUse */) {\n          b[j] = bNode = directClone(bNode);\n        }\n        ++j;\n        mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n      }\n    }\n  } else if (j > bEnd) {\n    while (j <= aEnd) {\n      remove(a[j++], dom);\n    }\n  } else {\n    patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n  }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n  var aNode;\n  var bNode;\n  var nextPos;\n  var i = 0;\n  var aStart = j;\n  var bStart = j;\n  var aLeft = aEnd - j + 1;\n  var bLeft = bEnd - j + 1;\n  var sources = new Int32Array(bLeft + 1);\n  // Keep track if its possible to remove whole DOM using textContent = '';\n  var canRemoveWholeContent = aLeft === aLength;\n  var moved = false;\n  var pos = 0;\n  var patched = 0;\n  // When sizes are small, just loop them through\n  if (bLength < 4 || (aLeft | bLeft) < 32) {\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n      if (patched < bLeft) {\n        for (j = bStart; j <= bEnd; j++) {\n          bNode = b[j];\n          if (aNode.key === bNode.key) {\n            sources[j - bStart] = i + 1;\n            if (canRemoveWholeContent) {\n              canRemoveWholeContent = false;\n              while (aStart < i) {\n                remove(a[aStart++], dom);\n              }\n            }\n            if (pos > j) {\n              moved = true;\n            } else {\n              pos = j;\n            }\n            if (bNode.flags & 16384 /* InUse */) {\n              b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            ++patched;\n            break;\n          }\n        }\n        if (!canRemoveWholeContent && j > bEnd) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  } else {\n    var keyIndex = {};\n    // Map keys by their index\n    for (i = bStart; i <= bEnd; ++i) {\n      keyIndex[b[i].key] = i;\n    }\n    // Try to patch same keys\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n      if (patched < bLeft) {\n        j = keyIndex[aNode.key];\n        if (j !== void 0) {\n          if (canRemoveWholeContent) {\n            canRemoveWholeContent = false;\n            while (i > aStart) {\n              remove(a[aStart++], dom);\n            }\n          }\n          sources[j - bStart] = i + 1;\n          if (pos > j) {\n            moved = true;\n          } else {\n            pos = j;\n          }\n          bNode = b[j];\n          if (bNode.flags & 16384 /* InUse */) {\n            b[j] = bNode = directClone(bNode);\n          }\n          patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n          ++patched;\n        } else if (!canRemoveWholeContent) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  }\n  // fast-path: if nothing patched remove all old and add all new\n  if (canRemoveWholeContent) {\n    removeAllChildren(dom, parentVNode, a);\n    mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n  } else if (moved) {\n    var seq = lis_algorithm(sources);\n    j = seq.length - 1;\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n        if (bNode.flags & 16384 /* InUse */) {\n          b[pos] = bNode = directClone(bNode);\n        }\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      } else if (j < 0 || i !== seq[j]) {\n        pos = i + bStart;\n        bNode = b[pos];\n        nextPos = pos + 1;\n        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n      } else {\n        j--;\n      }\n    }\n  } else if (patched !== bLeft) {\n    // when patched count doesn't match b length we need to insert those new ones\n    // loop backwards so we can use insertBefore\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n        if (bNode.flags & 16384 /* InUse */) {\n          b[pos] = bNode = directClone(bNode);\n        }\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      }\n    }\n  }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n  var arrI = 0;\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var u = 0;\n  var v = 0;\n  var c = 0;\n  var len = arr.length;\n  if (len > maxLen) {\n    maxLen = len;\n    result = new Int32Array(len);\n    p = new Int32Array(len);\n  }\n  for (; i < len; ++i) {\n    arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[k];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result[++k] = i;\n        continue;\n      }\n      u = 0;\n      v = k;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = k + 1;\n  var seq = new Int32Array(u);\n  v = result[u - 1];\n  while (u-- > 0) {\n    seq[u] = v;\n    v = p[v];\n    result[u] = 0;\n  }\n  return seq;\n}\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n  /*\n   * Defining $EV and $V properties on Node.prototype\n   * fixes v8 \"wrong map\" de-optimization\n   */\n  if (window.Node) {\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n  }\n}\nfunction __render(input, parentDOM, callback, context) {\n  var lifecycle = [];\n  var rootInput = parentDOM.$V;\n  renderCheck.v = true;\n  if (isNullOrUndef(rootInput)) {\n    if (!isNullOrUndef(input)) {\n      if (input.flags & 16384 /* InUse */) {\n        input = directClone(input);\n      }\n      mount(input, parentDOM, context, false, null, lifecycle);\n      parentDOM.$V = input;\n      rootInput = input;\n    }\n  } else {\n    if (isNullOrUndef(input)) {\n      remove(rootInput, parentDOM);\n      parentDOM.$V = null;\n    } else {\n      if (input.flags & 16384 /* InUse */) {\n        input = directClone(input);\n      }\n      patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n      rootInput = parentDOM.$V = input;\n    }\n  }\n  callAll(lifecycle);\n  renderCheck.v = false;\n  if (isFunction(callback)) {\n    callback();\n  }\n  if (isFunction(options.renderComplete)) {\n    options.renderComplete(rootInput, parentDOM);\n  }\n}\nfunction render(input, parentDOM, callback, context) {\n  if (callback === void 0) callback = null;\n  if (context === void 0) context = EMPTY_OBJ;\n  __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n  return function renderer(lastInput, nextInput, callback, context) {\n    if (!parentDOM) {\n      parentDOM = lastInput;\n    }\n    render(nextInput, parentDOM, callback, context);\n  };\n}\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : function (a) {\n  window.setTimeout(a, 0);\n};\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n  var pending = component.$PS;\n  if (isFunction(newState)) {\n    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n  }\n  if (isNullOrUndef(pending)) {\n    component.$PS = newState;\n  } else {\n    for (var stateKey in newState) {\n      pending[stateKey] = newState[stateKey];\n    }\n  }\n  if (!component.$BR) {\n    if (!renderCheck.v) {\n      if (QUEUE.length === 0) {\n        applyState(component, force);\n        if (isFunction(callback)) {\n          callback.call(component);\n        }\n        return;\n      }\n    }\n    if (QUEUE.indexOf(component) === -1) {\n      QUEUE.push(component);\n    }\n    if (force) {\n      component.$F = true;\n    }\n    if (!microTaskPending) {\n      microTaskPending = true;\n      nextTick(rerender);\n    }\n    if (isFunction(callback)) {\n      var QU = component.$QU;\n      if (!QU) {\n        QU = component.$QU = [];\n      }\n      QU.push(callback);\n    }\n  } else if (isFunction(callback)) {\n    component.$L.push(callback.bind(component));\n  }\n}\nfunction callSetStateCallbacks(component) {\n  var queue = component.$QU;\n  for (var i = 0; i < queue.length; ++i) {\n    queue[i].call(component);\n  }\n  component.$QU = null;\n}\nfunction rerender() {\n  var component;\n  microTaskPending = false;\n  while (component = QUEUE.shift()) {\n    if (!component.$UN) {\n      var force = component.$F;\n      component.$F = false;\n      applyState(component, force);\n      if (component.$QU) {\n        callSetStateCallbacks(component);\n      }\n    }\n  }\n}\nfunction applyState(component, force) {\n  if (force || !component.$BR) {\n    var pendingState = component.$PS;\n    component.$PS = null;\n    var lifecycle = [];\n    renderCheck.v = true;\n    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n    callAll(lifecycle);\n    renderCheck.v = false;\n  } else {\n    component.state = component.$PS;\n    component.$PS = null;\n  }\n}\nvar Component = function Component(props, context) {\n  // Public\n  this.state = null;\n  // Internal properties\n  this.$BR = false; // BLOCK RENDER\n  this.$BS = true; // BLOCK STATE\n  this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n  this.$LI = null; // LAST INPUT\n  this.$UN = false; // UNMOUNTED\n  this.$CX = null; // CHILDCONTEXT\n  this.$QU = null; // QUEUE\n  this.$N = false; // Uses new lifecycle API Flag\n  this.$L = null; // Current lifecycle of this component\n  this.$SVG = false; // Flag to keep track if component is inside SVG tree\n  this.$F = false; // Force update flag\n  this.props = props || EMPTY_OBJ;\n  this.context = context || EMPTY_OBJ; // context should not be mutable\n};\n\nComponent.prototype.forceUpdate = function forceUpdate(callback) {\n  if (this.$UN) {\n    return;\n  }\n  // Do not allow double render during force update\n  queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState(newState, callback) {\n  if (this.$UN) {\n    return;\n  }\n  if (!this.$BS) {\n    queueStateChanges(this, newState, callback, false);\n  }\n};\nComponent.prototype.render = function render(_nextProps, _nextState, _nextContext) {\n  return null;\n};\nvar version = \"7.4.11\";\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };","map":{"version":3,"names":["isArray","Array","isStringOrNumber","o","type","isNullOrUndef","isInvalid","isFunction","isString","isNumber","isNull","isUndefined","combineFrom","first","second","out","key","key$1","linkEvent","data","event","isLinkEventObject","EMPTY_OBJ","Fragment","normalizeEventName","name","substr","toLowerCase","appendChild","parentDOM","dom","insertOrAppend","newNode","nextNode","insertBefore","documentCreateElement","tag","isSVG","document","createElementNS","createElement","replaceChild","newDom","lastDom","removeChild","childNode","callAll","arrayFn","i","length","findChildVNode","vNode","startEdge","flags","children","$LI","childFlags","findDOMfromVNode","removeVNodeDOM","len","moveVNodeDOM","createDerivedState","instance","nextProps","state","constructor","getDerivedStateFromProps","renderCheck","v","options","componentComparator","createVNode","renderComplete","setTextContent","textContent","isLastValueSameLinkEvent","lastValue","nextValue","mergeUnsetProperties","to","from","propName","safeCall1","method","arg1","keyPrefix","V","className","props","ref","childFlag","normalizeChildren","mergeDefaultHooks","defaultHooks","render","mergeDefaultProps","defaultProps","resolveComponentFlags","prototype","createComponentVNode","createTextVNode","text","createFragment","fragment","createVoidVNode","normalizeProps","undefined","cloneFragment","vNodeToClone","oldChildren","directClone","map","propsToClone","createPortal","container","normalizedRoot","normalizeRoot","_normalizeVNodes","nodes","result","index","currentKey","n","newKey","oldKey","isPrefixedKey","substring","push","getFlagsForElementVnode","newChildren","newChildFlags","slice","needsCloning","isNullKey","isPrefixed","input","xlinkNS","xmlNS","namespaces","getDelegatedEventObject","onClick","onDblClick","onFocusIn","onFocusOut","onKeyDown","onKeyPress","onKeyUp","onMouseDown","onMouseMove","onMouseUp","onTouchEnd","onTouchMove","onTouchStart","attachedEventCounts","attachedEvents","syntheticEvents","updateOrAddSyntheticEvent","eventsObject","$EV","attachEventToDocument","unmountSyntheticEvent","removeEventListener","handleSyntheticEvent","lastEvent","nextEvent","getTargetNode","composedPath","target","dispatchEvents","isClick","eventData","disabled","currentEvent","cancelBubble","parentNode","stopPropagation","immediatePropagationStopped","stopImmediatePropagation","isDefaultPrevented","defaultPrevented","isPropagationStopped","extendEventProperties","Object","defineProperty","configurable","get","rootClickEvent","button","rootEvent","attachedEvent","addEventListener","isSameInnerHTML","innerHTML","tempdom","triggerEventListener","methodName","e","listener","nativeListenerName","createWrappedFunction","applyValue","fnMethod","$V","newVNode","newProps","enumerable","value","writable","attachEvent","eventName","handler","previousKey","previousArgs","wrapped","isCheckedType","onTextInputChange","applyValueInput","wrappedOnChange","emptywrapper","inputEvents","nextPropsOrEmpty","checked","multiple","defaultValue","hasValue","setAttribute","updateChildOptions","updateChildOption","indexOf","selected","onSelectChange","applyValueSelect","selectEvents","mounting","multiplePropInBoolean","Boolean","selectedIndex","onTextareaInputChange","applyValueTextArea","wrappedOnChange$1","textAreaEvents","onChange","domValue","processElement","isControlled","addFormElementEventHandlers","isControlledFormElement","createRef","current","forwardRef","unmountRef","mountRef","lifecycle","remove","unmount","keys","unmountAllChildren","componentWillUnmount","$UN","onComponentWillUnmount","clearDOM","removeAllChildren","wrapLinkEvent","ev","patchEvent","patchStyle","lastAttrValue","nextAttrValue","removeAttribute","domStyle","style","cssText","setProperty","removeProperty","patchDangerInnerHTML","lastVNode","lastHtml","__html","nextHtml","patchProp","prop","hasControlledValue","autofocus","charCodeAt","setAttributeNS","mountProps","isFormElement","renderNewInput","context","nextInput","childContext","getChildContext","$CX","createClassComponentInstance","Component","usesNewAPI","$N","getSnapshotBeforeUpdate","$SVG","$L","$BS","componentWillMount","$BR","pending","$PS","renderFunctionalComponent","mount","mountElement","mountClassComponent","mountFunctionalComponent","mountFunctionalComponentCallbacks","mountText","mountFragment","mountPortal","placeHolderVNode","mountArrayChildren","createTextNode","childrenIsSVG","child","mountClassComponentCallbacks","createClassMountCallback","componentDidMount","createOnMountCallback","onComponentDidMount","onComponentWillMount","replaceWithNewNode","nextVNode","patch","nextFlags","patchElement","patchClassComponent","patchFunctionalComponent","patchText","patchFragment","patchPortal","patchSingleTextChild","lastChildren","nextChildren","firstChild","nodeValue","patchContentEditableChildren","lastChildFlags","nextChildFlags","nextIsSingle","lastLen","nextSibling","patchChildren","lastContainer","nextContainer","node","lastProps","lastPropsOrEmpty","prop$1","nextClassName","nextRef","lastRef","replaceOneVNodeWithMultipleVNodes","parentVNode","lastLength","nextLength","patchKeyedChildren","patchNonKeyedChildren","createDidUpdate","lastState","snapshot","componentDidUpdate","updateClassComponent","nextState","force","hasSCU","shouldComponentUpdate","componentWillUpdate","componentWillReceiveProps","shouldUpdate","nextHooksDefined","lastInput","onComponentShouldUpdate","onComponentWillUpdate","onComponentDidUpdate","nextText","lastChildrenLength","nextChildrenLength","commonLength","nextChild","lastChild","a","b","aLength","bLength","outerEdge","aEnd","bEnd","j","aNode","bNode","nextPos","outer","patchKeyedChildrenComplex","aStart","bStart","aLeft","bLeft","sources","Int32Array","canRemoveWholeContent","moved","pos","patched","keyIndex","seq","lis_algorithm","p","maxLen","arr","arrI","k","u","c","hasDocumentAvailable","window","Node","__render","callback","rootInput","createRenderer","renderer","QUEUE","nextTick","Promise","resolve","then","bind","setTimeout","microTaskPending","queueStateChanges","component","newState","stateKey","applyState","call","$F","rerender","QU","$QU","callSetStateCallbacks","queue","shift","pendingState","forceUpdate","setState","_nextProps","_nextState","_nextContext","version","_CI","_HI","_M","_MCCC","_ME","_MFCC","_MP","_MR","_RFC"],"sources":["C:/Users/ninad/OneDrive/Radna površina/zavrsni/client/node_modules/inferno/dist/index.esm.js"],"sourcesContent":["var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n    return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    for (var i = 0; i < arrayFn.length; i++) {\n        arrayFn[i]();\n    }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n        return children.$LI;\n    }\n    if (flags & 8192 /* Fragment */) {\n        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n    }\n    return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n    var flags;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        vNode = findChildVNode(vNode, startEdge, flags);\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            removeChild(parentDOM, vNode.dom);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            insertOrAppend(parentDOM, vNode.dom, nextNode);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n    return (isLinkEventObject(lastValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\nfunction mergeUnsetProperties(to, from) {\n    for (var propName in from) {\n        if (isUndefined(to[propName])) {\n            to[propName] = from[propName];\n        }\n    }\n    return to;\n}\nfunction safeCall1(method, arg1) {\n    return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n    if (flags & 4 /* ComponentClass */) {\n        return ref;\n    }\n    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n    if (isNullOrUndef(defaultHooks)) {\n        return ref;\n    }\n    if (isNullOrUndef(ref)) {\n        return defaultHooks;\n    }\n    return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n    // set default props\n    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n    if (isNullOrUndef(defaultProps)) {\n        return props;\n    }\n    if (isNullOrUndef(props)) {\n        return combineFrom(defaultProps, null);\n    }\n    return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n    if (flags & 12 /* ComponentKnown */) {\n        return flags;\n    }\n    if (type.prototype && type.prototype.render) {\n        return 4 /* ComponentClass */;\n    }\n    if (type.render) {\n        return 32776 /* ForwardRefComponent */;\n    }\n    return 8 /* ComponentFunction */;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    flags = resolveComponentFlags(flags, type);\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                if (isNullOrUndef(vNode.className)) {\n                    vNode.className = props.className || null;\n                }\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    var normalizedRoot = normalizeRoot(children);\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nfunction normalizeRoot(input) {\n    if (isInvalid(input) || isStringOrNumber(input)) {\n        return createTextVNode(input, null);\n    }\n    if (isArray(input)) {\n        return createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (!eventsObject) {\n        eventsObject = dom.$EV = getDelegatedEventObject(null);\n    }\n    if (!eventsObject[name]) {\n        if (++attachedEventCounts[name] === 1) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n    }\n    return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n    if (isFunction(nextEvent)) {\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else if (isLinkEventObject(nextEvent)) {\n        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n            return;\n        }\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else {\n        unmountSyntheticEvent(name, dom);\n    }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n    var dom = getTargetNode(event);\n    do {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    } while (!isNull(dom));\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n    // Event data needs to be object to save reference to currentTarget getter\n    var eventData = {\n        dom: document\n    };\n    event.isDefaultPrevented = isDefaultPrevented;\n    event.isPropagationStopped = isPropagationStopped;\n    event.stopPropagation = stopPropagation;\n    Object.defineProperty(event, 'currentTarget', {\n        configurable: true,\n        get: function get() {\n            return eventData.dom;\n        }\n    });\n    return eventData;\n}\nfunction rootClickEvent(name) {\n    return function (event) {\n        if (event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 17 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        dispatchEvents(event, true, name, extendEventProperties(event));\n    };\n}\nfunction rootEvent(name) {\n    return function (event) {\n        dispatchEvents(event, false, name, extendEventProperties(event));\n    };\n}\nfunction attachEventToDocument(name) {\n    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n    document.addEventListener(normalizeEventName(name), attachedEvent);\n    return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n    var previousKey = \"$\" + eventName;\n    var previousArgs = dom[previousKey];\n    if (previousArgs) {\n        if (previousArgs[1].wrapped) {\n            return;\n        }\n        dom.removeEventListener(previousArgs[0], previousArgs[1]);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(eventName, handler);\n        dom[previousKey] = [eventName, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nfunction forwardRef(render) {\n    // @ts-ignore\n    return {\n        render: render\n    };\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (!safeCall1(ref, null) && ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref && (isFunction(ref) || ref.current !== void 0)) {\n        lifecycle.push(function () {\n            if (!safeCall1(ref, value) && ref.current !== void 0) {\n                ref.current = value;\n            }\n        });\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (syntheticEvents[key]) {\n                    unmountSyntheticEvent(key, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction wrapLinkEvent(nextValue) {\n    // This variable makes sure there is no \"this\" context in callback\n    var ev = nextValue.event;\n    return function (e) {\n        ev(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (isLinkEventObject(nextValue)) {\n        if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n            return;\n        }\n        nextValue = wrapLinkEvent(nextValue);\n    }\n    attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n    var lastHtml = (lastValue && lastValue.__html) || '';\n    var nextHtml = (nextValue && nextValue.__html) || '';\n    if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n            if (!isNull(lastVNode)) {\n                if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                    unmountAllChildren(lastVNode.children);\n                }\n                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                    unmount(lastVNode.children);\n                }\n                lastVNode.children = null;\n                lastVNode.childFlags = 1 /* HasInvalidChildren */;\n            }\n            dom.innerHTML = nextHtml;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n        case 'selectedIndex':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n            break;\n        default:\n            if (syntheticEvents[prop]) {\n                handleSyntheticEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction renderFunctionalComponent(vNode, context) {\n    var props = vNode.props || EMPTY_OBJ;\n    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        mountFunctionalComponentCallbacks(vNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n    else ;\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var childFlags = vNode.childFlags;\n    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));\n    var children = vNode.children;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n    };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n    var ref = vNode.ref;\n    if (!isNullOrUndef(ref)) {\n        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = (nextVNode.dom = lastVNode.dom);\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = (nextVNode.dom = lastVNode.dom);\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n    }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n    var aNode;\n    var bNode;\n    var nextPos;\n    var i = 0;\n    var aStart = j;\n    var bStart = j;\n    var aLeft = aEnd - j + 1;\n    var bLeft = bEnd - j + 1;\n    var sources = new Int32Array(bLeft + 1);\n    // Keep track if its possible to remove whole DOM using textContent = '';\n    var canRemoveWholeContent = aLeft === aLength;\n    var moved = false;\n    var pos = 0;\n    var patched = 0;\n    // When sizes are small, just loop them through\n    if (bLength < 4 || (aLeft | bLeft) < 32) {\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                for (j = bStart; j <= bEnd; j++) {\n                    bNode = b[j];\n                    if (aNode.key === bNode.key) {\n                        sources[j - bStart] = i + 1;\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (aStart < i) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                        break;\n                    }\n                }\n                if (!canRemoveWholeContent && j > bEnd) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    else {\n        var keyIndex = {};\n        // Map keys by their index\n        for (i = bStart; i <= bEnd; ++i) {\n            keyIndex[b[i].key] = i;\n        }\n        // Try to patch same keys\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                j = keyIndex[aNode.key];\n                if (j !== void 0) {\n                    if (canRemoveWholeContent) {\n                        canRemoveWholeContent = false;\n                        while (i > aStart) {\n                            remove(a[aStart++], dom);\n                        }\n                    }\n                    sources[j - bStart] = i + 1;\n                    if (pos > j) {\n                        moved = true;\n                    }\n                    else {\n                        pos = j;\n                    }\n                    bNode = b[j];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[j] = bNode = directClone(bNode);\n                    }\n                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                    ++patched;\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    // fast-path: if nothing patched remove all old and add all new\n    if (canRemoveWholeContent) {\n        removeAllChildren(dom, parentVNode, a);\n        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n    }\n    else if (moved) {\n        var seq = lis_algorithm(sources);\n        j = seq.length - 1;\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n            else if (j < 0 || i !== seq[j]) {\n                pos = i + bStart;\n                bNode = b[pos];\n                nextPos = pos + 1;\n                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n            }\n            else {\n                j--;\n            }\n        }\n    }\n    else if (patched !== bLeft) {\n        // when patched count doesn't match b length we need to insert those new ones\n        // loop backwards so we can use insertBefore\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n        result[u] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    if (window.Node) {\n        Node.prototype.$EV = null;\n        Node.prototype.$V = null;\n    }\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    callAll(lifecycle);\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : function (a) {\n        window.setTimeout(a, 0);\n    };\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force);\n                if (isFunction(callback)) {\n                    callback.call(component);\n                }\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (force) {\n            component.$F = true;\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0; i < queue.length; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.shift())) {\n        if (!component.$UN) {\n            var force = component.$F;\n            component.$F = false;\n            applyState(component, force);\n            if (component.$QU) {\n                callSetStateCallbacks(component);\n            }\n        }\n    }\n}\nfunction applyState(component, force) {\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        callAll(lifecycle);\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.$F = false; // Force update flag\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.4.11\";\n\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}