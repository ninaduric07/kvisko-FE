{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\nconst removeNodeAndCleanParent = _ref => {\n  let {\n    node,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref;\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n  const parentNode = tree[node.parent];\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\nconst replaceDataGroupWithAutoGeneratedGroup = _ref2 => {\n  let {\n    node,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref2;\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\nexport const removeDataRowFromTree = _ref3 => {\n  let {\n    id,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref3;\n  const node = tree[id];\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","getNodePathInTree","getGroupRowIdFromPath","removeNodeFromTree","updateGroupNodeIdAndAutoGenerated","removeNodeAndCleanParent","_ref","node","tree","treeDepths","updatedGroupsManager","type","footerId","parentNode","parent","addAction","id","shouldDeleteGroup","children","length","isAutoGenerated","depth","groupingKey","replaceDataGroupWithAutoGeneratedGroup","_ref2","previousTree","updatedNode","removeDataRowFromTree","_ref3"],"sources":["C:/Users/ninad/OneDrive/Radna povrÅ¡ina/zavrsni/client/node_modules/@mui/x-data-grid-pro/utils/tree/removeDataRowFromTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\nconst removeNodeAndCleanParent = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n  const parentNode = tree[node.parent];\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\nconst replaceDataGroupWithAutoGeneratedGroup = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\nexport const removeDataRowFromTree = ({\n  id,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  const node = tree[id];\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}