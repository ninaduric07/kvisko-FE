{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/module_aggregate_calculator.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Class from \"../../../core/class\";\nimport { compileGetter } from \"../../../core/utils/data\";\nimport { isFunction } from \"../../../core/utils/type\";\nimport { errors } from \"../../../data/errors\";\nimport { aggregators } from \"../../../data/utils\";\nfunction depthFirstSearch(i, depth, root, callback) {\n  let j = 0;\n  if (i < depth) {\n    for (; j < root.items.length; j++) {\n      depthFirstSearch(i + 1, depth, root.items[j], callback);\n    }\n  }\n  if (i === depth) {\n    callback(root);\n  }\n}\nfunction map(array, callback) {\n  let i;\n  if (\"map\" in array) {\n    return array.map(callback);\n  }\n  const result = new Array(array.length);\n  for (i in array) {\n    result[i] = callback(array[i], i);\n  }\n  return result;\n}\nfunction isEmpty(x) {\n  return x !== x || \"\" === x || null === x || void 0 === x;\n}\nfunction isCount(aggregator) {\n  return aggregator === aggregators.count;\n}\nfunction normalizeAggregate(aggregate) {\n  const selector = compileGetter(aggregate.selector);\n  const skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true;\n  let {\n    aggregator: aggregator\n  } = aggregate;\n  if (\"string\" === typeof aggregator) {\n    aggregator = aggregators[aggregator];\n    if (!aggregator) {\n      throw errors.Error(\"E4001\", aggregate.aggregator);\n    }\n  }\n  return {\n    selector: selector,\n    aggregator: aggregator,\n    skipEmptyValues: skipEmptyValues\n  };\n}\nexport default Class.inherit({\n  ctor(options) {\n    this._data = options.data;\n    this._groupLevel = options.groupLevel || 0;\n    this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\n    this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\n    this._totals = [];\n  },\n  calculate() {\n    if (this._totalAggregates.length) {\n      this._calculateTotals(0, {\n        items: this._data\n      });\n    }\n    if (this._groupAggregates.length && this._groupLevel > 0) {\n      this._calculateGroups({\n        items: this._data\n      });\n    }\n  },\n  totalAggregates() {\n    return this._totals;\n  },\n  _aggregate(aggregates, data, container) {\n    const length = data.items ? data.items.length : 0;\n    for (let i = 0; i < aggregates.length; i++) {\n      if (isCount(aggregates[i].aggregator)) {\n        container[i] = (container[i] || 0) + length;\n        continue;\n      }\n      for (let j = 0; j < length; j++) {\n        this._accumulate(i, aggregates[i], container, data.items[j]);\n      }\n    }\n  },\n  _calculateTotals(level, data) {\n    if (0 === level) {\n      this._totals = this._seed(this._totalAggregates);\n    }\n    if (level === this._groupLevel) {\n      this._aggregate(this._totalAggregates, data, this._totals);\n    } else {\n      for (let i = 0; i < data.items.length; i++) {\n        this._calculateTotals(level + 1, data.items[i]);\n      }\n    }\n    if (0 === level) {\n      this._totals = this._finalize(this._totalAggregates, this._totals);\n    }\n  },\n  _calculateGroups(root) {\n    const maxLevel = this._groupLevel;\n    let currentLevel = maxLevel + 1;\n    const seedFn = this._seed.bind(this, this._groupAggregates);\n    const stepFn = this._aggregate.bind(this, this._groupAggregates);\n    const finalizeFn = this._finalize.bind(this, this._groupAggregates);\n    function aggregator(node) {\n      node.aggregates = seedFn(currentLevel - 1);\n      if (currentLevel === maxLevel) {\n        stepFn(node, node.aggregates);\n      } else {\n        depthFirstSearch(currentLevel, maxLevel, node, innerNode => {\n          stepFn(innerNode, node.aggregates);\n        });\n      }\n      node.aggregates = finalizeFn(node.aggregates);\n    }\n    while (--currentLevel > 0) {\n      depthFirstSearch(0, currentLevel, root, aggregator);\n    }\n  },\n  _seed: (aggregates, groupIndex) => map(aggregates, aggregate => {\n    const {\n      aggregator: aggregator\n    } = aggregate;\n    const seed = \"seed\" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\n    return seed;\n  }),\n  _accumulate(aggregateIndex, aggregate, results, item) {\n    const value = aggregate.selector(item);\n    const {\n      aggregator: aggregator\n    } = aggregate;\n    const {\n      skipEmptyValues: skipEmptyValues\n    } = aggregate;\n    if (skipEmptyValues && isEmpty(value)) {\n      return;\n    }\n    if (results[aggregateIndex] !== results[aggregateIndex]) {\n      results[aggregateIndex] = value;\n    } else {\n      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value);\n    }\n  },\n  _finalize: (aggregates, results) => map(aggregates, (aggregate, index) => {\n    const fin = aggregate.aggregator.finalize;\n    return fin ? fin(results[index]) : results[index];\n  })\n});","map":{"version":3,"names":["Class","compileGetter","isFunction","errors","aggregators","depthFirstSearch","i","depth","root","callback","j","items","length","map","array","result","Array","isEmpty","x","isCount","aggregator","count","normalizeAggregate","aggregate","selector","skipEmptyValues","Error","inherit","ctor","options","_data","data","_groupLevel","groupLevel","_totalAggregates","totalAggregates","_groupAggregates","groupAggregates","_totals","calculate","_calculateTotals","_calculateGroups","_aggregate","aggregates","container","_accumulate","level","_seed","_finalize","maxLevel","currentLevel","seedFn","bind","stepFn","finalizeFn","node","innerNode","groupIndex","seed","NaN","aggregateIndex","results","item","value","step","index","fin","finalize"],"sources":["C:/Users/ninad/OneDrive/Radna povr≈°ina/zavrsni/client/node_modules/devextreme/esm/__internal/grids/data_grid/module_aggregate_calculator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/module_aggregate_calculator.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport Class from \"../../../core/class\";\r\nimport {\r\n    compileGetter\r\n} from \"../../../core/utils/data\";\r\nimport {\r\n    isFunction\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    errors\r\n} from \"../../../data/errors\";\r\nimport {\r\n    aggregators\r\n} from \"../../../data/utils\";\r\n\r\nfunction depthFirstSearch(i, depth, root, callback) {\r\n    let j = 0;\r\n    if (i < depth) {\r\n        for (; j < root.items.length; j++) {\r\n            depthFirstSearch(i + 1, depth, root.items[j], callback)\r\n        }\r\n    }\r\n    if (i === depth) {\r\n        callback(root)\r\n    }\r\n}\r\n\r\nfunction map(array, callback) {\r\n    let i;\r\n    if (\"map\" in array) {\r\n        return array.map(callback)\r\n    }\r\n    const result = new Array(array.length);\r\n    for (i in array) {\r\n        result[i] = callback(array[i], i)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction isEmpty(x) {\r\n    return x !== x || \"\" === x || null === x || void 0 === x\r\n}\r\n\r\nfunction isCount(aggregator) {\r\n    return aggregator === aggregators.count\r\n}\r\n\r\nfunction normalizeAggregate(aggregate) {\r\n    const selector = compileGetter(aggregate.selector);\r\n    const skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true;\r\n    let {\r\n        aggregator: aggregator\r\n    } = aggregate;\r\n    if (\"string\" === typeof aggregator) {\r\n        aggregator = aggregators[aggregator];\r\n        if (!aggregator) {\r\n            throw errors.Error(\"E4001\", aggregate.aggregator)\r\n        }\r\n    }\r\n    return {\r\n        selector: selector,\r\n        aggregator: aggregator,\r\n        skipEmptyValues: skipEmptyValues\r\n    }\r\n}\r\nexport default Class.inherit({\r\n    ctor(options) {\r\n        this._data = options.data;\r\n        this._groupLevel = options.groupLevel || 0;\r\n        this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\r\n        this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\r\n        this._totals = []\r\n    },\r\n    calculate() {\r\n        if (this._totalAggregates.length) {\r\n            this._calculateTotals(0, {\r\n                items: this._data\r\n            })\r\n        }\r\n        if (this._groupAggregates.length && this._groupLevel > 0) {\r\n            this._calculateGroups({\r\n                items: this._data\r\n            })\r\n        }\r\n    },\r\n    totalAggregates() {\r\n        return this._totals\r\n    },\r\n    _aggregate(aggregates, data, container) {\r\n        const length = data.items ? data.items.length : 0;\r\n        for (let i = 0; i < aggregates.length; i++) {\r\n            if (isCount(aggregates[i].aggregator)) {\r\n                container[i] = (container[i] || 0) + length;\r\n                continue\r\n            }\r\n            for (let j = 0; j < length; j++) {\r\n                this._accumulate(i, aggregates[i], container, data.items[j])\r\n            }\r\n        }\r\n    },\r\n    _calculateTotals(level, data) {\r\n        if (0 === level) {\r\n            this._totals = this._seed(this._totalAggregates)\r\n        }\r\n        if (level === this._groupLevel) {\r\n            this._aggregate(this._totalAggregates, data, this._totals)\r\n        } else {\r\n            for (let i = 0; i < data.items.length; i++) {\r\n                this._calculateTotals(level + 1, data.items[i])\r\n            }\r\n        }\r\n        if (0 === level) {\r\n            this._totals = this._finalize(this._totalAggregates, this._totals)\r\n        }\r\n    },\r\n    _calculateGroups(root) {\r\n        const maxLevel = this._groupLevel;\r\n        let currentLevel = maxLevel + 1;\r\n        const seedFn = this._seed.bind(this, this._groupAggregates);\r\n        const stepFn = this._aggregate.bind(this, this._groupAggregates);\r\n        const finalizeFn = this._finalize.bind(this, this._groupAggregates);\r\n\r\n        function aggregator(node) {\r\n            node.aggregates = seedFn(currentLevel - 1);\r\n            if (currentLevel === maxLevel) {\r\n                stepFn(node, node.aggregates)\r\n            } else {\r\n                depthFirstSearch(currentLevel, maxLevel, node, innerNode => {\r\n                    stepFn(innerNode, node.aggregates)\r\n                })\r\n            }\r\n            node.aggregates = finalizeFn(node.aggregates)\r\n        }\r\n        while (--currentLevel > 0) {\r\n            depthFirstSearch(0, currentLevel, root, aggregator)\r\n        }\r\n    },\r\n    _seed: (aggregates, groupIndex) => map(aggregates, aggregate => {\r\n        const {\r\n            aggregator: aggregator\r\n        } = aggregate;\r\n        const seed = \"seed\" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\r\n        return seed\r\n    }),\r\n    _accumulate(aggregateIndex, aggregate, results, item) {\r\n        const value = aggregate.selector(item);\r\n        const {\r\n            aggregator: aggregator\r\n        } = aggregate;\r\n        const {\r\n            skipEmptyValues: skipEmptyValues\r\n        } = aggregate;\r\n        if (skipEmptyValues && isEmpty(value)) {\r\n            return\r\n        }\r\n        if (results[aggregateIndex] !== results[aggregateIndex]) {\r\n            results[aggregateIndex] = value\r\n        } else {\r\n            results[aggregateIndex] = aggregator.step(results[aggregateIndex], value)\r\n        }\r\n    },\r\n    _finalize: (aggregates, results) => map(aggregates, (aggregate, index) => {\r\n        const fin = aggregate.aggregator.finalize;\r\n        return fin ? fin(results[index]) : results[index]\r\n    })\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}