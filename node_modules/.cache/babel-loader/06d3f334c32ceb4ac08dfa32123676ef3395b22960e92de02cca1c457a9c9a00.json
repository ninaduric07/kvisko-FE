{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_collapsed.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../../../core/utils/extend\";\nimport { each } from \"../../../../core/utils/iterator\";\nimport errors from \"../../../../ui/widget/ui.errors\";\nimport { errors as dataErrors } from \"../../../../data/errors\";\nimport { when, Deferred } from \"../../../../core/utils/deferred\";\nimport dataGridCore from \"../module_core\";\nimport { GroupingHelper as GroupingHelperCore, createOffsetFilter } from \"./module_core\";\nimport { createGroupFilter } from \"../module_utils\";\nfunction getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {\n  groupIndex = groupIndex || 0;\n  if (pageSize > 1 && groupSize > 0) {\n    let pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;\n    pageOffset += groupSize - groupIndex - 2;\n    if (pageOffset < 0) {\n      pageOffset += pageSize;\n    }\n    return Math.floor(pageOffset / (pageSize - groupIndex - 1));\n  }\n  return 0;\n}\nexport const GroupingHelper = GroupingHelperCore.inherit(function () {\n  const foreachExpandedGroups = function (that, callback, updateGroups) {\n    return that.foreachGroups((groupInfo, parents) => {\n      if (groupInfo.isExpanded) {\n        return callback(groupInfo, parents);\n      }\n    }, true, false, updateGroups, updateGroups);\n  };\n  const processGroupItems = function (that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {\n    let isExpanded;\n    expandedInfo.items = expandedInfo.items || [];\n    expandedInfo.paths = expandedInfo.paths || [];\n    expandedInfo.count = expandedInfo.count || 0;\n    expandedInfo.lastCount = expandedInfo.lastCount || 0;\n    if (!groupsCount) {\n      return;\n    }\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (void 0 !== item.items) {\n        path.push(item.key);\n        if (isCustomLoading) {\n          isExpanded = true;\n        } else {\n          const groupInfo = that.findGroupInfo(path);\n          isExpanded = groupInfo && groupInfo.isExpanded;\n        }\n        if (!isExpanded) {\n          item.collapsedItems = item.items;\n          item.items = null;\n        } else if (item.items) {\n          processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);\n        } else if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {\n          expandedInfo.items.push(item);\n          expandedInfo.paths.push(path.slice(0));\n          expandedInfo.count += expandedInfo.lastCount;\n          expandedInfo.lastCount = item.count;\n        }\n        path.pop();\n      }\n    }\n  };\n  const updateGroupInfoItem = function (that, item, isLastGroupLevel, path, offset) {\n    const groupInfo = that.findGroupInfo(path);\n    let count;\n    if (!groupInfo) {\n      if (isLastGroupLevel) {\n        count = item.count > 0 ? item.count : item.items.length;\n      }\n      that.addGroupInfo({\n        isExpanded: that._isGroupExpanded(path.length - 1),\n        path: path.slice(0),\n        offset: offset,\n        count: count || 0\n      });\n    } else {\n      if (isLastGroupLevel) {\n        groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0;\n      } else {\n        item.count = groupInfo.count || item.count;\n      }\n      groupInfo.offset = offset;\n    }\n  };\n  const updateGroupInfos = function (that, options, items, loadedGroupCount, groupIndex, path, parentIndex) {\n    const groupCount = options.group ? options.group.length : 0;\n    const isLastGroupLevel = groupCount === loadedGroupCount;\n    const remotePaging = options.remoteOperations.paging;\n    let offset = 0;\n    let totalCount = 0;\n    let count;\n    groupIndex = groupIndex || 0;\n    path = path || [];\n    if (remotePaging && !parentIndex) {\n      offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0;\n    }\n    if (groupIndex >= loadedGroupCount) {\n      return items.length;\n    }\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (item) {\n        path.push(item.key);\n        if (!item.count && !item.items || void 0 === item.items) {\n          return -1;\n        }\n        updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);\n        count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;\n        if (count < 0) {\n          return -1;\n        }\n        totalCount += count;\n        path.pop();\n      }\n    }\n    return totalCount;\n  };\n  const isGroupExpanded = function (groups, groupIndex) {\n    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded;\n  };\n  const getTotalOffset = function (groupInfos, pageSize, offset) {\n    let groupSize;\n    let totalOffset = offset;\n    for (let groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {\n      groupSize = groupInfos[groupIndex].offset + 1;\n      if (groupIndex > 0) {\n        groupSize += groupInfos[groupIndex - 1].childrenTotalCount;\n        if (pageSize) {\n          groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex;\n        }\n      }\n      totalOffset += groupSize;\n    }\n    return totalOffset;\n  };\n  function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {\n    const item = expandedInfo.items[expandedItemIndex];\n    const skip = options.skips && options.skips[groupLevel];\n    const take = options.takes && options.takes[groupLevel];\n    const isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;\n    const isFirstExpandedItem = 0 === expandedItemIndex;\n    const lastExpandedItemSkip = isFirstExpandedItem && skip || 0;\n    const isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;\n    if (isFirstExpandedItem && void 0 !== skip) {\n      item.isContinuation = true;\n    }\n    if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {\n      item.isContinuationOnNextPage = true;\n    }\n  }\n  function isDataDeferred(data) {\n    return !Array.isArray(data);\n  }\n  function makeDataDeferred(options) {\n    if (!isDataDeferred(options.data)) {\n      options.data = new Deferred();\n    }\n  }\n  function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data) {\n    if (!options.isCustomLoading) {\n      expandedInfo = {};\n      processGroupItems(that, data, loadedGroupCount, expandedInfo, []);\n      !function (options, expandedInfo, currentGroupCount) {\n        const currentGroupIndex = currentGroupCount - 1;\n        const groupCount = options.group ? options.group.length : 0;\n        expandedInfo.skip = options.skips && options.skips[currentGroupIndex];\n        if (options.takes && void 0 !== options.takes[currentGroupIndex]) {\n          if (groupCount === currentGroupCount) {\n            expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;\n          } else {\n            expandedInfo.take = 0;\n          }\n          expandedInfo.take += options.takes[currentGroupIndex];\n        }\n      }(options, expandedInfo, loadedGroupCount);\n    }\n    const groupCount = options.group ? options.group.length : 0;\n    if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {\n      makeDataDeferred(options);\n      !function (that, options, expandedInfo, loadedGroupCount, groupLevel, data) {\n        const groups = options.group || [];\n        const currentGroup = groups[groupLevel + 1];\n        const deferreds = [];\n        each(expandedInfo.paths, expandedItemIndex => {\n          const loadOptions = {\n            requireTotalCount: false,\n            requireGroupCount: true,\n            group: [currentGroup],\n            groupSummary: options.storeLoadOptions.groupSummary,\n            filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {\n              filter: options.storeLoadOptions.filter,\n              group: groups\n            }),\n            select: options.storeLoadOptions.select\n          };\n          if (0 === expandedItemIndex) {\n            loadOptions.skip = expandedInfo.skip || 0;\n          }\n          if (expandedItemIndex === expandedInfo.paths.length - 1) {\n            loadOptions.take = expandedInfo.take;\n          }\n          const loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);\n          when(loadResult).done(data => {\n            const item = expandedInfo.items[expandedItemIndex];\n            applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);\n            item.items = data;\n          });\n          deferreds.push(loadResult);\n        });\n        when.apply(null, deferreds).done(() => {\n          updateGroupInfos(that, options, data, loadedGroupCount + 1);\n          loadGroupItems(that, options, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data);\n        });\n      }(that, options, expandedInfo, loadedGroupCount, groupLevel, data);\n    } else if (expandedInfo.paths.length && options.storeLoadOptions.group) {\n      makeDataDeferred(options);\n      !function (that, options, expandedInfo, data) {\n        const expandedFilters = [];\n        const groups = options.group || [];\n        each(expandedInfo.paths, (_, expandedPath) => {\n          expandedFilters.push(createGroupFilter(expandedPath, {\n            group: options.isCustomLoading ? options.storeLoadOptions.group : groups\n          }));\n        });\n        let {\n          filter: filter\n        } = options.storeLoadOptions;\n        if (!options.storeLoadOptions.isLoadingAll) {\n          filter = dataGridCore.combineFilters([filter, dataGridCore.combineFilters(expandedFilters, \"or\")]);\n        }\n        const loadOptions = extend({}, options.storeLoadOptions, {\n          requireTotalCount: false,\n          requireGroupCount: false,\n          group: null,\n          sort: groups.concat(dataGridCore.normalizeSortingInfo(options.storeLoadOptions.sort || [])),\n          filter: filter\n        });\n        const isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();\n        if (!isPagingLocal) {\n          loadOptions.skip = expandedInfo.skip;\n          loadOptions.take = expandedInfo.take;\n        }\n        when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(items => {\n          if (isPagingLocal) {\n            items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);\n            items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;\n            items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items;\n          }\n          each(expandedInfo.items, (index, item) => {\n            const itemCount = item.count - (0 === index && expandedInfo.skip || 0);\n            const expandedItems = items.splice(0, itemCount);\n            applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);\n            item.items = expandedItems;\n          });\n          options.data.resolve(data);\n        }).fail(options.data.reject);\n      }(that, options, expandedInfo, data);\n    } else if (isDataDeferred(options.data)) {\n      options.data.resolve(data);\n    }\n  }\n  const loadGroupTotalCount = function (dataSource, options) {\n    const d = new Deferred();\n    const isGrouping = !!(options.group && options.group.length);\n    const loadOptions = extend({\n      skip: 0,\n      take: 1,\n      requireGroupCount: isGrouping,\n      requireTotalCount: !isGrouping\n    }, options, {\n      group: isGrouping ? options.group : null\n    });\n    dataSource.load(loadOptions).done((data, extra) => {\n      const count = extra && (isGrouping ? extra.groupCount : extra.totalCount);\n      if (!isFinite(count)) {\n        d.reject(dataErrors.Error(isGrouping ? \"E4022\" : \"E4021\"));\n        return;\n      }\n      d.resolve(count);\n    }).fail(d.reject.bind(d));\n    return d;\n  };\n  return {\n    updateTotalItemsCount(options) {\n      let totalItemsCount = 0;\n      const totalCount = options.extra && options.extra.totalCount || 0;\n      const groupCount = options.extra && options.extra.groupCount || 0;\n      const pageSize = this._dataSource.pageSize();\n      const isVirtualPaging = this._isVirtualPaging();\n      foreachExpandedGroups(this, groupInfo => {\n        groupInfo.childrenTotalCount = 0;\n      });\n      foreachExpandedGroups(this, (groupInfo, parents) => {\n        const totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount);\n        let count = groupInfo.count + groupInfo.childrenTotalCount;\n        if (!isVirtualPaging) {\n          count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);\n        }\n        if (parents[parents.length - 2]) {\n          parents[parents.length - 2].childrenTotalCount += count;\n        } else {\n          totalItemsCount += count;\n        }\n      });\n      this.callBase(totalItemsCount - totalCount + groupCount);\n    },\n    _isGroupExpanded(groupIndex) {\n      const groups = this._dataSource.group();\n      return isGroupExpanded(groups, groupIndex);\n    },\n    _updatePagingOptions(options, callback) {\n      const that = this;\n      const isVirtualPaging = that._isVirtualPaging();\n      const pageSize = that._dataSource.pageSize();\n      const skips = [];\n      const takes = [];\n      let skipChildrenTotalCount = 0;\n      let childrenTotalCount = 0;\n      if (options.take) {\n        foreachExpandedGroups(this, groupInfo => {\n          groupInfo.childrenTotalCount = 0;\n          groupInfo.skipChildrenTotalCount = 0;\n        });\n        foreachExpandedGroups(that, (groupInfo, parents) => {\n          let take;\n          let takeCorrection = 0;\n          let parentTakeCorrection = 0;\n          const totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount);\n          let continuationGroupCount = 0;\n          let skipContinuationGroupCount = 0;\n          let groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;\n          let childrenGroupInfoCount = groupInfoCount;\n          callback && callback(groupInfo, totalOffset);\n          const skip = options.skip - totalOffset;\n          if (totalOffset <= options.skip + options.take && groupInfoCount) {\n            take = options.take;\n            if (!isVirtualPaging) {\n              continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);\n              groupInfoCount += continuationGroupCount * parents.length;\n              childrenGroupInfoCount += continuationGroupCount;\n              if (pageSize && skip >= 0) {\n                takeCorrection = parents.length;\n                parentTakeCorrection = parents.length - 1;\n                skipContinuationGroupCount = Math.floor(skip / pageSize);\n              }\n            }\n            if (skip >= 0) {\n              if (totalOffset + groupInfoCount > options.skip) {\n                skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);\n              }\n              if (totalOffset + groupInfoCount >= options.skip + take) {\n                takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount);\n              }\n            } else if (totalOffset + groupInfoCount >= options.skip + take) {\n              takes.unshift(take + skip - groupInfo.childrenTotalCount);\n            }\n          }\n          if (totalOffset <= options.skip) {\n            if (parents[parents.length - 2]) {\n              parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);\n            } else {\n              skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);\n            }\n          }\n          if (totalOffset <= options.skip + take) {\n            groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);\n            if (parents[parents.length - 2]) {\n              parents[parents.length - 2].childrenTotalCount += groupInfoCount;\n            } else {\n              childrenTotalCount += groupInfoCount;\n            }\n          }\n        });\n        options.skip -= skipChildrenTotalCount;\n        options.take -= childrenTotalCount - skipChildrenTotalCount;\n      }\n      options.skips = skips;\n      options.takes = takes;\n    },\n    changeRowExpand(path) {\n      const groupInfo = this.findGroupInfo(path);\n      const dataSource = this._dataSource;\n      const remoteGroupPaging = dataSource.remoteOperations().groupPaging;\n      const groups = dataGridCore.normalizeSortingInfo(dataSource.group());\n      if (groupInfo) {\n        groupInfo.isExpanded = !groupInfo.isExpanded;\n        if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {\n          return loadGroupTotalCount(dataSource, {\n            filter: createGroupFilter(path, {\n              filter: dataSource.lastLoadOptions().filter,\n              group: dataSource.group()\n            }),\n            group: [groups[path.length]],\n            select: dataSource.select()\n          }).done(groupCount => {\n            groupInfo.count = groupCount;\n          });\n        }\n        return new Deferred().resolve();\n      }\n      return new Deferred().reject();\n    },\n    handleDataLoading(options) {\n      const that = this;\n      const {\n        storeLoadOptions: storeLoadOptions\n      } = options;\n      const groups = dataGridCore.normalizeSortingInfo(storeLoadOptions.group || options.loadOptions.group);\n      if (options.isCustomLoading || !groups.length) {\n        return;\n      }\n      if (options.remoteOperations.grouping) {\n        const remotePaging = that._dataSource.remoteOperations().paging;\n        storeLoadOptions.group = dataGridCore.normalizeSortingInfo(storeLoadOptions.group);\n        storeLoadOptions.group.forEach((group, index) => {\n          const isLastGroup = index === storeLoadOptions.group.length - 1;\n          group.isExpanded = !remotePaging || !isLastGroup;\n        });\n      }\n      options.group = options.group || groups;\n      if (options.remoteOperations.paging) {\n        options.skip = storeLoadOptions.skip;\n        options.take = storeLoadOptions.take;\n        storeLoadOptions.requireGroupCount = true;\n        storeLoadOptions.group = groups.slice(0, 1);\n        that._updatePagingOptions(options);\n        storeLoadOptions.skip = options.skip;\n        storeLoadOptions.take = options.take;\n      } else {\n        options.skip = options.loadOptions.skip;\n        options.take = options.loadOptions.take;\n        that._updatePagingOptions(options);\n      }\n    },\n    handleDataLoadedCore(options, callBase) {\n      const that = this;\n      const loadedGroupCount = dataGridCore.normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length;\n      const groupCount = options.group ? options.group.length : 0;\n      let totalCount;\n      const expandedInfo = {};\n      if (options.isCustomLoading) {\n        callBase(options);\n        processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll);\n      } else {\n        if (!options.remoteOperations.paging) {\n          that.foreachGroups(groupInfo => {\n            groupInfo.count = 0;\n          });\n        }\n        totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);\n        if (totalCount < 0) {\n          options.data = new Deferred().reject(errors.Error(\"E1037\"));\n          return;\n        }\n        if (!options.remoteOperations.paging) {\n          if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {\n            options.extra.totalCount = totalCount;\n            options.extra.groupCount = options.data.length;\n          }\n        }\n        if (groupCount && options.storeLoadOptions.requireGroupCount && !isFinite(options.extra.groupCount)) {\n          options.data = new Deferred().reject(dataErrors.Error(\"E4022\"));\n          return;\n        }\n        that.updateTotalItemsCount(options);\n        if (!options.remoteOperations.paging) {\n          that._updatePagingOptions(options);\n        }\n        callBase(options);\n        if (!options.remoteOperations.paging) {\n          that._processPaging(options, loadedGroupCount);\n        }\n      }\n      loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data);\n    },\n    _processSkips(items, skips, groupCount) {\n      if (!groupCount) {\n        return;\n      }\n      const firstItem = items[0];\n      const skip = skips[0];\n      const children = firstItem && firstItem.items;\n      if (void 0 !== skip) {\n        firstItem.isContinuation = true;\n        if (children) {\n          firstItem.items = children.slice(skip);\n          this._processSkips(firstItem.items, skips.slice(1), groupCount - 1);\n        }\n      }\n    },\n    _processTakes(items, skips, takes, groupCount, parents) {\n      if (!groupCount || !items) {\n        return;\n      }\n      parents = parents || [];\n      const lastItem = items[items.length - 1];\n      let children = lastItem && lastItem.items;\n      const take = takes[0];\n      const skip = skips[0];\n      if (lastItem) {\n        const maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;\n        if (void 0 !== take && maxTakeCount > take) {\n          lastItem.isContinuationOnNextPage = true;\n          parents.forEach(parent => {\n            parent.isContinuationOnNextPage = true;\n          });\n          if (children) {\n            children = children.slice(0, take);\n            lastItem.items = children;\n          }\n        }\n        parents.push(lastItem);\n        this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents);\n      }\n    },\n    _processPaging(options, groupCount) {\n      this._processSkips(options.data, options.skips, groupCount);\n      this._processTakes(options.data, options.skips, options.takes, groupCount);\n    },\n    isLastLevelGroupItemsPagingLocal: () => false,\n    sortLastLevelGroupItems: items => items,\n    refresh(options, operationTypes) {\n      const that = this;\n      const dataSource = that._dataSource;\n      const {\n        storeLoadOptions: storeLoadOptions\n      } = options;\n      const group = options.group || options.storeLoadOptions.group;\n      const oldGroups = dataGridCore.normalizeSortingInfo(that._group);\n      let isExpanded;\n      let groupIndex;\n      function handleGroup(groupInfo, parents) {\n        if (parents.length === groupIndex + 1) {\n          groupInfo.isExpanded = isExpanded;\n        }\n      }\n      for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {\n        isExpanded = isGroupExpanded(group, groupIndex);\n        if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {\n          that.foreachGroups(handleGroup);\n        }\n      }\n      that.callBase.apply(this, arguments);\n      if (group && options.remoteOperations.paging && operationTypes.reload) {\n        return foreachExpandedGroups(that, groupInfo => {\n          const groupCountQuery = loadGroupTotalCount(dataSource, {\n            filter: createGroupFilter(groupInfo.path, {\n              filter: storeLoadOptions.filter,\n              group: group\n            }),\n            group: group.slice(groupInfo.path.length),\n            select: storeLoadOptions.select\n          });\n          const groupOffsetQuery = loadGroupTotalCount(dataSource, {\n            filter: createOffsetFilter(groupInfo.path, {\n              filter: storeLoadOptions.filter,\n              group: group\n            }, true),\n            group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),\n            select: storeLoadOptions.select\n          });\n          return when(groupOffsetQuery, groupCountQuery).done((offset, count) => {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount(options);\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());\nexport { getContinuationGroupCount };","map":{"version":3,"names":["extend","each","errors","dataErrors","when","Deferred","dataGridCore","GroupingHelper","GroupingHelperCore","createOffsetFilter","createGroupFilter","getContinuationGroupCount","groupOffset","pageSize","groupSize","groupIndex","pageOffset","Math","floor","inherit","foreachExpandedGroups","that","callback","updateGroups","foreachGroups","groupInfo","parents","isExpanded","processGroupItems","items","groupsCount","expandedInfo","path","isCustomLoading","isLastGroupExpanded","paths","count","lastCount","i","length","item","push","key","findGroupInfo","collapsedItems","slice","pop","updateGroupInfoItem","isLastGroupLevel","offset","addGroupInfo","_isGroupExpanded","updateGroupInfos","options","loadedGroupCount","parentIndex","groupCount","group","remotePaging","remoteOperations","paging","totalCount","skip","skips","isGroupExpanded","groups","getTotalOffset","groupInfos","totalOffset","childrenTotalCount","applyContinuationToGroupItem","groupLevel","expandedItemIndex","take","takes","isLastExpandedItem","isFirstExpandedItem","lastExpandedItemSkip","isItemsTruncatedByTake","isContinuation","isContinuationOnNextPage","isDataDeferred","data","Array","isArray","makeDataDeferred","loadGroupItems","currentGroupCount","currentGroupIndex","currentGroup","deferreds","loadOptions","requireTotalCount","requireGroupCount","groupSummary","storeLoadOptions","filter","select","loadResult","_dataSource","loadFromStore","done","apply","expandedFilters","_","expandedPath","isLoadingAll","combineFilters","sort","concat","normalizeSortingInfo","isPagingLocal","isLastLevelGroupItemsPagingLocal","sortLastLevelGroupItems","index","itemCount","expandedItems","splice","resolve","fail","reject","loadGroupTotalCount","dataSource","d","isGrouping","load","extra","isFinite","Error","bind","updateTotalItemsCount","totalItemsCount","isVirtualPaging","_isVirtualPaging","callBase","_updatePagingOptions","skipChildrenTotalCount","takeCorrection","parentTakeCorrection","continuationGroupCount","skipContinuationGroupCount","groupInfoCount","childrenGroupInfoCount","unshift","min","changeRowExpand","remoteGroupPaging","groupPaging","lastLoadOptions","handleDataLoading","grouping","forEach","isLastGroup","handleDataLoadedCore","_processPaging","_processSkips","firstItem","children","_processTakes","lastItem","maxTakeCount","parent","refresh","operationTypes","oldGroups","_group","handleGroup","arguments","reload","groupCountQuery","groupOffsetQuery","parseInt"],"sources":["C:/Users/ninad/OneDrive/Radna povrÅ¡ina/zavrsni/client/node_modules/devextreme/esm/__internal/grids/data_grid/grouping/module_collapsed.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/module_collapsed.js)\r\n * Version: 22.2.6\r\n * Build date: Tue Apr 18 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    extend\r\n} from \"../../../../core/utils/extend\";\r\nimport {\r\n    each\r\n} from \"../../../../core/utils/iterator\";\r\nimport errors from \"../../../../ui/widget/ui.errors\";\r\nimport {\r\n    errors as dataErrors\r\n} from \"../../../../data/errors\";\r\nimport {\r\n    when,\r\n    Deferred\r\n} from \"../../../../core/utils/deferred\";\r\nimport dataGridCore from \"../module_core\";\r\nimport {\r\n    GroupingHelper as GroupingHelperCore,\r\n    createOffsetFilter\r\n} from \"./module_core\";\r\nimport {\r\n    createGroupFilter\r\n} from \"../module_utils\";\r\n\r\nfunction getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {\r\n    groupIndex = groupIndex || 0;\r\n    if (pageSize > 1 && groupSize > 0) {\r\n        let pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;\r\n        pageOffset += groupSize - groupIndex - 2;\r\n        if (pageOffset < 0) {\r\n            pageOffset += pageSize\r\n        }\r\n        return Math.floor(pageOffset / (pageSize - groupIndex - 1))\r\n    }\r\n    return 0\r\n}\r\nexport const GroupingHelper = GroupingHelperCore.inherit(function() {\r\n    const foreachExpandedGroups = function(that, callback, updateGroups) {\r\n        return that.foreachGroups((groupInfo, parents) => {\r\n            if (groupInfo.isExpanded) {\r\n                return callback(groupInfo, parents)\r\n            }\r\n        }, true, false, updateGroups, updateGroups)\r\n    };\r\n    const processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {\r\n        let isExpanded;\r\n        expandedInfo.items = expandedInfo.items || [];\r\n        expandedInfo.paths = expandedInfo.paths || [];\r\n        expandedInfo.count = expandedInfo.count || 0;\r\n        expandedInfo.lastCount = expandedInfo.lastCount || 0;\r\n        if (!groupsCount) {\r\n            return\r\n        }\r\n        for (let i = 0; i < items.length; i++) {\r\n            const item = items[i];\r\n            if (void 0 !== item.items) {\r\n                path.push(item.key);\r\n                if (isCustomLoading) {\r\n                    isExpanded = true\r\n                } else {\r\n                    const groupInfo = that.findGroupInfo(path);\r\n                    isExpanded = groupInfo && groupInfo.isExpanded\r\n                }\r\n                if (!isExpanded) {\r\n                    item.collapsedItems = item.items;\r\n                    item.items = null\r\n                } else if (item.items) {\r\n                    processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded)\r\n                } else if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {\r\n                    expandedInfo.items.push(item);\r\n                    expandedInfo.paths.push(path.slice(0));\r\n                    expandedInfo.count += expandedInfo.lastCount;\r\n                    expandedInfo.lastCount = item.count\r\n                }\r\n                path.pop()\r\n            }\r\n        }\r\n    };\r\n    const updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset) {\r\n        const groupInfo = that.findGroupInfo(path);\r\n        let count;\r\n        if (!groupInfo) {\r\n            if (isLastGroupLevel) {\r\n                count = item.count > 0 ? item.count : item.items.length\r\n            }\r\n            that.addGroupInfo({\r\n                isExpanded: that._isGroupExpanded(path.length - 1),\r\n                path: path.slice(0),\r\n                offset: offset,\r\n                count: count || 0\r\n            })\r\n        } else {\r\n            if (isLastGroupLevel) {\r\n                groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0\r\n            } else {\r\n                item.count = groupInfo.count || item.count\r\n            }\r\n            groupInfo.offset = offset\r\n        }\r\n    };\r\n    const updateGroupInfos = function(that, options, items, loadedGroupCount, groupIndex, path, parentIndex) {\r\n        const groupCount = options.group ? options.group.length : 0;\r\n        const isLastGroupLevel = groupCount === loadedGroupCount;\r\n        const remotePaging = options.remoteOperations.paging;\r\n        let offset = 0;\r\n        let totalCount = 0;\r\n        let count;\r\n        groupIndex = groupIndex || 0;\r\n        path = path || [];\r\n        if (remotePaging && !parentIndex) {\r\n            offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0\r\n        }\r\n        if (groupIndex >= loadedGroupCount) {\r\n            return items.length\r\n        }\r\n        for (let i = 0; i < items.length; i++) {\r\n            const item = items[i];\r\n            if (item) {\r\n                path.push(item.key);\r\n                if (!item.count && !item.items || void 0 === item.items) {\r\n                    return -1\r\n                }\r\n                updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);\r\n                count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;\r\n                if (count < 0) {\r\n                    return -1\r\n                }\r\n                totalCount += count;\r\n                path.pop()\r\n            }\r\n        }\r\n        return totalCount\r\n    };\r\n    const isGroupExpanded = function(groups, groupIndex) {\r\n        return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded\r\n    };\r\n    const getTotalOffset = function(groupInfos, pageSize, offset) {\r\n        let groupSize;\r\n        let totalOffset = offset;\r\n        for (let groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {\r\n            groupSize = groupInfos[groupIndex].offset + 1;\r\n            if (groupIndex > 0) {\r\n                groupSize += groupInfos[groupIndex - 1].childrenTotalCount;\r\n                if (pageSize) {\r\n                    groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex\r\n                }\r\n            }\r\n            totalOffset += groupSize\r\n        }\r\n        return totalOffset\r\n    };\r\n\r\n    function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {\r\n        const item = expandedInfo.items[expandedItemIndex];\r\n        const skip = options.skips && options.skips[groupLevel];\r\n        const take = options.takes && options.takes[groupLevel];\r\n        const isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;\r\n        const isFirstExpandedItem = 0 === expandedItemIndex;\r\n        const lastExpandedItemSkip = isFirstExpandedItem && skip || 0;\r\n        const isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;\r\n        if (isFirstExpandedItem && void 0 !== skip) {\r\n            item.isContinuation = true\r\n        }\r\n        if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {\r\n            item.isContinuationOnNextPage = true\r\n        }\r\n    }\r\n\r\n    function isDataDeferred(data) {\r\n        return !Array.isArray(data)\r\n    }\r\n\r\n    function makeDataDeferred(options) {\r\n        if (!isDataDeferred(options.data)) {\r\n            options.data = new Deferred\r\n        }\r\n    }\r\n\r\n    function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data) {\r\n        if (!options.isCustomLoading) {\r\n            expandedInfo = {};\r\n            processGroupItems(that, data, loadedGroupCount, expandedInfo, []);\r\n            ! function(options, expandedInfo, currentGroupCount) {\r\n                const currentGroupIndex = currentGroupCount - 1;\r\n                const groupCount = options.group ? options.group.length : 0;\r\n                expandedInfo.skip = options.skips && options.skips[currentGroupIndex];\r\n                if (options.takes && void 0 !== options.takes[currentGroupIndex]) {\r\n                    if (groupCount === currentGroupCount) {\r\n                        expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0\r\n                    } else {\r\n                        expandedInfo.take = 0\r\n                    }\r\n                    expandedInfo.take += options.takes[currentGroupIndex]\r\n                }\r\n            }(options, expandedInfo, loadedGroupCount)\r\n        }\r\n        const groupCount = options.group ? options.group.length : 0;\r\n        if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {\r\n            makeDataDeferred(options);\r\n            ! function(that, options, expandedInfo, loadedGroupCount, groupLevel, data) {\r\n                const groups = options.group || [];\r\n                const currentGroup = groups[groupLevel + 1];\r\n                const deferreds = [];\r\n                each(expandedInfo.paths, expandedItemIndex => {\r\n                    const loadOptions = {\r\n                        requireTotalCount: false,\r\n                        requireGroupCount: true,\r\n                        group: [currentGroup],\r\n                        groupSummary: options.storeLoadOptions.groupSummary,\r\n                        filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {\r\n                            filter: options.storeLoadOptions.filter,\r\n                            group: groups\r\n                        }),\r\n                        select: options.storeLoadOptions.select\r\n                    };\r\n                    if (0 === expandedItemIndex) {\r\n                        loadOptions.skip = expandedInfo.skip || 0\r\n                    }\r\n                    if (expandedItemIndex === expandedInfo.paths.length - 1) {\r\n                        loadOptions.take = expandedInfo.take\r\n                    }\r\n                    const loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);\r\n                    when(loadResult).done(data => {\r\n                        const item = expandedInfo.items[expandedItemIndex];\r\n                        applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);\r\n                        item.items = data\r\n                    });\r\n                    deferreds.push(loadResult)\r\n                });\r\n                when.apply(null, deferreds).done(() => {\r\n                    updateGroupInfos(that, options, data, loadedGroupCount + 1);\r\n                    loadGroupItems(that, options, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data)\r\n                })\r\n            }(that, options, expandedInfo, loadedGroupCount, groupLevel, data)\r\n        } else if (expandedInfo.paths.length && options.storeLoadOptions.group) {\r\n            makeDataDeferred(options);\r\n            ! function(that, options, expandedInfo, data) {\r\n                const expandedFilters = [];\r\n                const groups = options.group || [];\r\n                each(expandedInfo.paths, (_, expandedPath) => {\r\n                    expandedFilters.push(createGroupFilter(expandedPath, {\r\n                        group: options.isCustomLoading ? options.storeLoadOptions.group : groups\r\n                    }))\r\n                });\r\n                let {\r\n                    filter: filter\r\n                } = options.storeLoadOptions;\r\n                if (!options.storeLoadOptions.isLoadingAll) {\r\n                    filter = dataGridCore.combineFilters([filter, dataGridCore.combineFilters(expandedFilters, \"or\")])\r\n                }\r\n                const loadOptions = extend({}, options.storeLoadOptions, {\r\n                    requireTotalCount: false,\r\n                    requireGroupCount: false,\r\n                    group: null,\r\n                    sort: groups.concat(dataGridCore.normalizeSortingInfo(options.storeLoadOptions.sort || [])),\r\n                    filter: filter\r\n                });\r\n                const isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();\r\n                if (!isPagingLocal) {\r\n                    loadOptions.skip = expandedInfo.skip;\r\n                    loadOptions.take = expandedInfo.take\r\n                }\r\n                when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(items => {\r\n                    if (isPagingLocal) {\r\n                        items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);\r\n                        items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;\r\n                        items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items\r\n                    }\r\n                    each(expandedInfo.items, (index, item) => {\r\n                        const itemCount = item.count - (0 === index && expandedInfo.skip || 0);\r\n                        const expandedItems = items.splice(0, itemCount);\r\n                        applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);\r\n                        item.items = expandedItems\r\n                    });\r\n                    options.data.resolve(data)\r\n                }).fail(options.data.reject)\r\n            }(that, options, expandedInfo, data)\r\n        } else if (isDataDeferred(options.data)) {\r\n            options.data.resolve(data)\r\n        }\r\n    }\r\n    const loadGroupTotalCount = function(dataSource, options) {\r\n        const d = new Deferred;\r\n        const isGrouping = !!(options.group && options.group.length);\r\n        const loadOptions = extend({\r\n            skip: 0,\r\n            take: 1,\r\n            requireGroupCount: isGrouping,\r\n            requireTotalCount: !isGrouping\r\n        }, options, {\r\n            group: isGrouping ? options.group : null\r\n        });\r\n        dataSource.load(loadOptions).done((data, extra) => {\r\n            const count = extra && (isGrouping ? extra.groupCount : extra.totalCount);\r\n            if (!isFinite(count)) {\r\n                d.reject(dataErrors.Error(isGrouping ? \"E4022\" : \"E4021\"));\r\n                return\r\n            }\r\n            d.resolve(count)\r\n        }).fail(d.reject.bind(d));\r\n        return d\r\n    };\r\n    return {\r\n        updateTotalItemsCount(options) {\r\n            let totalItemsCount = 0;\r\n            const totalCount = options.extra && options.extra.totalCount || 0;\r\n            const groupCount = options.extra && options.extra.groupCount || 0;\r\n            const pageSize = this._dataSource.pageSize();\r\n            const isVirtualPaging = this._isVirtualPaging();\r\n            foreachExpandedGroups(this, groupInfo => {\r\n                groupInfo.childrenTotalCount = 0\r\n            });\r\n            foreachExpandedGroups(this, (groupInfo, parents) => {\r\n                const totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount);\r\n                let count = groupInfo.count + groupInfo.childrenTotalCount;\r\n                if (!isVirtualPaging) {\r\n                    count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1)\r\n                }\r\n                if (parents[parents.length - 2]) {\r\n                    parents[parents.length - 2].childrenTotalCount += count\r\n                } else {\r\n                    totalItemsCount += count\r\n                }\r\n            });\r\n            this.callBase(totalItemsCount - totalCount + groupCount)\r\n        },\r\n        _isGroupExpanded(groupIndex) {\r\n            const groups = this._dataSource.group();\r\n            return isGroupExpanded(groups, groupIndex)\r\n        },\r\n        _updatePagingOptions(options, callback) {\r\n            const that = this;\r\n            const isVirtualPaging = that._isVirtualPaging();\r\n            const pageSize = that._dataSource.pageSize();\r\n            const skips = [];\r\n            const takes = [];\r\n            let skipChildrenTotalCount = 0;\r\n            let childrenTotalCount = 0;\r\n            if (options.take) {\r\n                foreachExpandedGroups(this, groupInfo => {\r\n                    groupInfo.childrenTotalCount = 0;\r\n                    groupInfo.skipChildrenTotalCount = 0\r\n                });\r\n                foreachExpandedGroups(that, (groupInfo, parents) => {\r\n                    let take;\r\n                    let takeCorrection = 0;\r\n                    let parentTakeCorrection = 0;\r\n                    const totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount);\r\n                    let continuationGroupCount = 0;\r\n                    let skipContinuationGroupCount = 0;\r\n                    let groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;\r\n                    let childrenGroupInfoCount = groupInfoCount;\r\n                    callback && callback(groupInfo, totalOffset);\r\n                    const skip = options.skip - totalOffset;\r\n                    if (totalOffset <= options.skip + options.take && groupInfoCount) {\r\n                        take = options.take;\r\n                        if (!isVirtualPaging) {\r\n                            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);\r\n                            groupInfoCount += continuationGroupCount * parents.length;\r\n                            childrenGroupInfoCount += continuationGroupCount;\r\n                            if (pageSize && skip >= 0) {\r\n                                takeCorrection = parents.length;\r\n                                parentTakeCorrection = parents.length - 1;\r\n                                skipContinuationGroupCount = Math.floor(skip / pageSize)\r\n                            }\r\n                        }\r\n                        if (skip >= 0) {\r\n                            if (totalOffset + groupInfoCount > options.skip) {\r\n                                skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount)\r\n                            }\r\n                            if (totalOffset + groupInfoCount >= options.skip + take) {\r\n                                takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)\r\n                            }\r\n                        } else if (totalOffset + groupInfoCount >= options.skip + take) {\r\n                            takes.unshift(take + skip - groupInfo.childrenTotalCount)\r\n                        }\r\n                    }\r\n                    if (totalOffset <= options.skip) {\r\n                        if (parents[parents.length - 2]) {\r\n                            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection)\r\n                        } else {\r\n                            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1)\r\n                        }\r\n                    }\r\n                    if (totalOffset <= options.skip + take) {\r\n                        groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);\r\n                        if (parents[parents.length - 2]) {\r\n                            parents[parents.length - 2].childrenTotalCount += groupInfoCount\r\n                        } else {\r\n                            childrenTotalCount += groupInfoCount\r\n                        }\r\n                    }\r\n                });\r\n                options.skip -= skipChildrenTotalCount;\r\n                options.take -= childrenTotalCount - skipChildrenTotalCount\r\n            }\r\n            options.skips = skips;\r\n            options.takes = takes\r\n        },\r\n        changeRowExpand(path) {\r\n            const groupInfo = this.findGroupInfo(path);\r\n            const dataSource = this._dataSource;\r\n            const remoteGroupPaging = dataSource.remoteOperations().groupPaging;\r\n            const groups = dataGridCore.normalizeSortingInfo(dataSource.group());\r\n            if (groupInfo) {\r\n                groupInfo.isExpanded = !groupInfo.isExpanded;\r\n                if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {\r\n                    return loadGroupTotalCount(dataSource, {\r\n                        filter: createGroupFilter(path, {\r\n                            filter: dataSource.lastLoadOptions().filter,\r\n                            group: dataSource.group()\r\n                        }),\r\n                        group: [groups[path.length]],\r\n                        select: dataSource.select()\r\n                    }).done(groupCount => {\r\n                        groupInfo.count = groupCount\r\n                    })\r\n                }\r\n                return (new Deferred).resolve()\r\n            }\r\n            return (new Deferred).reject()\r\n        },\r\n        handleDataLoading(options) {\r\n            const that = this;\r\n            const {\r\n                storeLoadOptions: storeLoadOptions\r\n            } = options;\r\n            const groups = dataGridCore.normalizeSortingInfo(storeLoadOptions.group || options.loadOptions.group);\r\n            if (options.isCustomLoading || !groups.length) {\r\n                return\r\n            }\r\n            if (options.remoteOperations.grouping) {\r\n                const remotePaging = that._dataSource.remoteOperations().paging;\r\n                storeLoadOptions.group = dataGridCore.normalizeSortingInfo(storeLoadOptions.group);\r\n                storeLoadOptions.group.forEach((group, index) => {\r\n                    const isLastGroup = index === storeLoadOptions.group.length - 1;\r\n                    group.isExpanded = !remotePaging || !isLastGroup\r\n                })\r\n            }\r\n            options.group = options.group || groups;\r\n            if (options.remoteOperations.paging) {\r\n                options.skip = storeLoadOptions.skip;\r\n                options.take = storeLoadOptions.take;\r\n                storeLoadOptions.requireGroupCount = true;\r\n                storeLoadOptions.group = groups.slice(0, 1);\r\n                that._updatePagingOptions(options);\r\n                storeLoadOptions.skip = options.skip;\r\n                storeLoadOptions.take = options.take\r\n            } else {\r\n                options.skip = options.loadOptions.skip;\r\n                options.take = options.loadOptions.take;\r\n                that._updatePagingOptions(options)\r\n            }\r\n        },\r\n        handleDataLoadedCore(options, callBase) {\r\n            const that = this;\r\n            const loadedGroupCount = dataGridCore.normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length;\r\n            const groupCount = options.group ? options.group.length : 0;\r\n            let totalCount;\r\n            const expandedInfo = {};\r\n            if (options.isCustomLoading) {\r\n                callBase(options);\r\n                processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll)\r\n            } else {\r\n                if (!options.remoteOperations.paging) {\r\n                    that.foreachGroups(groupInfo => {\r\n                        groupInfo.count = 0\r\n                    })\r\n                }\r\n                totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);\r\n                if (totalCount < 0) {\r\n                    options.data = (new Deferred).reject(errors.Error(\"E1037\"));\r\n                    return\r\n                }\r\n                if (!options.remoteOperations.paging) {\r\n                    if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {\r\n                        options.extra.totalCount = totalCount;\r\n                        options.extra.groupCount = options.data.length\r\n                    }\r\n                }\r\n                if (groupCount && options.storeLoadOptions.requireGroupCount && !isFinite(options.extra.groupCount)) {\r\n                    options.data = (new Deferred).reject(dataErrors.Error(\"E4022\"));\r\n                    return\r\n                }\r\n                that.updateTotalItemsCount(options);\r\n                if (!options.remoteOperations.paging) {\r\n                    that._updatePagingOptions(options)\r\n                }\r\n                callBase(options);\r\n                if (!options.remoteOperations.paging) {\r\n                    that._processPaging(options, loadedGroupCount)\r\n                }\r\n            }\r\n            loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data)\r\n        },\r\n        _processSkips(items, skips, groupCount) {\r\n            if (!groupCount) {\r\n                return\r\n            }\r\n            const firstItem = items[0];\r\n            const skip = skips[0];\r\n            const children = firstItem && firstItem.items;\r\n            if (void 0 !== skip) {\r\n                firstItem.isContinuation = true;\r\n                if (children) {\r\n                    firstItem.items = children.slice(skip);\r\n                    this._processSkips(firstItem.items, skips.slice(1), groupCount - 1)\r\n                }\r\n            }\r\n        },\r\n        _processTakes(items, skips, takes, groupCount, parents) {\r\n            if (!groupCount || !items) {\r\n                return\r\n            }\r\n            parents = parents || [];\r\n            const lastItem = items[items.length - 1];\r\n            let children = lastItem && lastItem.items;\r\n            const take = takes[0];\r\n            const skip = skips[0];\r\n            if (lastItem) {\r\n                const maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;\r\n                if (void 0 !== take && maxTakeCount > take) {\r\n                    lastItem.isContinuationOnNextPage = true;\r\n                    parents.forEach(parent => {\r\n                        parent.isContinuationOnNextPage = true\r\n                    });\r\n                    if (children) {\r\n                        children = children.slice(0, take);\r\n                        lastItem.items = children\r\n                    }\r\n                }\r\n                parents.push(lastItem);\r\n                this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents)\r\n            }\r\n        },\r\n        _processPaging(options, groupCount) {\r\n            this._processSkips(options.data, options.skips, groupCount);\r\n            this._processTakes(options.data, options.skips, options.takes, groupCount)\r\n        },\r\n        isLastLevelGroupItemsPagingLocal: () => false,\r\n        sortLastLevelGroupItems: items => items,\r\n        refresh(options, operationTypes) {\r\n            const that = this;\r\n            const dataSource = that._dataSource;\r\n            const {\r\n                storeLoadOptions: storeLoadOptions\r\n            } = options;\r\n            const group = options.group || options.storeLoadOptions.group;\r\n            const oldGroups = dataGridCore.normalizeSortingInfo(that._group);\r\n            let isExpanded;\r\n            let groupIndex;\r\n\r\n            function handleGroup(groupInfo, parents) {\r\n                if (parents.length === groupIndex + 1) {\r\n                    groupInfo.isExpanded = isExpanded\r\n                }\r\n            }\r\n            for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {\r\n                isExpanded = isGroupExpanded(group, groupIndex);\r\n                if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {\r\n                    that.foreachGroups(handleGroup)\r\n                }\r\n            }\r\n            that.callBase.apply(this, arguments);\r\n            if (group && options.remoteOperations.paging && operationTypes.reload) {\r\n                return foreachExpandedGroups(that, groupInfo => {\r\n                    const groupCountQuery = loadGroupTotalCount(dataSource, {\r\n                        filter: createGroupFilter(groupInfo.path, {\r\n                            filter: storeLoadOptions.filter,\r\n                            group: group\r\n                        }),\r\n                        group: group.slice(groupInfo.path.length),\r\n                        select: storeLoadOptions.select\r\n                    });\r\n                    const groupOffsetQuery = loadGroupTotalCount(dataSource, {\r\n                        filter: createOffsetFilter(groupInfo.path, {\r\n                            filter: storeLoadOptions.filter,\r\n                            group: group\r\n                        }, true),\r\n                        group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),\r\n                        select: storeLoadOptions.select\r\n                    });\r\n                    return when(groupOffsetQuery, groupCountQuery).done((offset, count) => {\r\n                        offset = parseInt(offset.length ? offset[0] : offset);\r\n                        count = parseInt(count.length ? count[0] : count);\r\n                        groupInfo.offset = offset;\r\n                        if (groupInfo.count !== count) {\r\n                            groupInfo.count = count;\r\n                            that.updateTotalItemsCount(options)\r\n                        }\r\n                    })\r\n                }, true)\r\n            }\r\n        }\r\n    }\r\n}());\r\nexport {\r\n    getContinuationGroupCount\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}