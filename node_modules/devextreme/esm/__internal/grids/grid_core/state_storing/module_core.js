/**
 * DevExtreme (esm/__internal/grids/grid_core/state_storing/module_core.js)
 * Version: 22.2.6
 * Build date: Tue Apr 18 2023
 *
 * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import eventsEngine from "../../../../events/core/events_engine";
import {
    getWindow
} from "../../../../core/utils/window";
import errors from "../../../../ui/widget/ui.errors";
import {
    sessionStorage
} from "../../../../core/utils/storage";
import {
    extend
} from "../../../../core/utils/extend";
import {
    each
} from "../../../../core/utils/iterator";
import {
    isDefined,
    isPlainObject,
    isEmptyObject
} from "../../../../core/utils/type";
import {
    fromPromise
} from "../../../../core/utils/deferred";
import modules from "../modules";
const DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
const parseDates = function(state) {
    if (!state) {
        return
    }
    each(state, (key, value) => {
        if (isPlainObject(value) || Array.isArray(value)) {
            parseDates(value)
        } else if ("string" === typeof value) {
            const date = DATE_REGEX.exec(value);
            if (date) {
                state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
            }
        }
    })
};
const StateStoringController = modules.ViewController.inherit(function() {
    const getStorage = function(options) {
        const storage = "sessionStorage" === options.type ? sessionStorage() : getWindow().localStorage;
        if (!storage) {
            throw new Error("E1007")
        }
        return storage
    };
    const getUniqueStorageKey = function(options) {
        return isDefined(options.storageKey) ? options.storageKey : "storage"
    };
    return {
        _loadState() {
            const options = this.option("stateStoring");
            if ("custom" === options.type) {
                return options.customLoad && options.customLoad()
            }
            try {
                return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
            } catch (e) {
                errors.log(e.message)
            }
        },
        _saveState(state) {
            const options = this.option("stateStoring");
            if ("custom" === options.type) {
                options.customSave && options.customSave(state);
                return
            }
            try {
                getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
            } catch (e) {
                errors.log(e.message)
            }
        },
        publicMethods: () => ["state"],
        isEnabled() {
            return this.option("stateStoring.enabled")
        },
        init() {
            const that = this;
            that._state = {};
            that._isLoaded = false;
            that._isLoading = false;
            that._windowUnloadHandler = function() {
                if (void 0 !== that._savingTimeoutID) {
                    that._saveState(that.state())
                }
            };
            eventsEngine.on(getWindow(), "unload", that._windowUnloadHandler);
            return that
        },
        isLoaded() {
            return this._isLoaded
        },
        isLoading() {
            return this._isLoading
        },
        load() {
            this._isLoading = true;
            const loadResult = fromPromise(this._loadState());
            loadResult.always(() => {
                this._isLoaded = true;
                this._isLoading = false
            }).done(state => {
                if (null !== state && !isEmptyObject(state)) {
                    this.state(state)
                }
            });
            return loadResult
        },
        state(state) {
            const that = this;
            if (!arguments.length) {
                return extend(true, {}, that._state)
            }
            that._state = extend({}, state);
            parseDates(that._state)
        },
        save() {
            const that = this;
            clearTimeout(that._savingTimeoutID);
            that._savingTimeoutID = setTimeout(() => {
                that._saveState(that.state());
                that._savingTimeoutID = void 0
            }, that.option("stateStoring.savingTimeout"))
        },
        optionChanged(args) {
            const that = this;
            switch (args.name) {
                case "stateStoring":
                    if (that.isEnabled() && !that.isLoading()) {
                        that.load()
                    }
                    args.handled = true;
                    break;
                default:
                    that.callBase(args)
            }
        },
        dispose() {
            clearTimeout(this._savingTimeoutID);
            eventsEngine.off(getWindow(), "unload", this._windowUnloadHandler)
        }
    }
}());
export default {
    StateStoringController: StateStoringController
};
