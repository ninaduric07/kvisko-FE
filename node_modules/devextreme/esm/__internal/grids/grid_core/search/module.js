/**
 * DevExtreme (esm/__internal/grids/grid_core/search/module.js)
 * Version: 22.2.6
 * Build date: Tue Apr 18 2023
 *
 * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import $ from "../../../../core/renderer";
import domAdapter from "../../../../core/dom_adapter";
import {
    isDefined
} from "../../../../core/utils/type";
import {
    compileGetter
} from "../../../../core/utils/data";
import messageLocalization from "../../../../localization/message";
import dataQuery from "../../../../data/query";
import gridCoreUtils from "../module_utils";
const SEARCH_PANEL_CLASS = "search-panel";
const SEARCH_TEXT_CLASS = "search-text";
const HEADER_PANEL_CLASS = "header-panel";
const FILTERING_TIMEOUT = 700;

function allowSearch(column) {
    return isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
}

function parseValue(column, text) {
    const {
        lookup: lookup
    } = column;
    if (!column.parseValue) {
        return text
    }
    if (lookup) {
        return column.parseValue.call(lookup, text)
    }
    return column.parseValue(text)
}
export const searchModule = {
    defaultOptions: () => ({
        searchPanel: {
            visible: false,
            width: 160,
            placeholder: messageLocalization.format("dxDataGrid-searchPanelPlaceholder"),
            highlightSearchText: true,
            highlightCaseSensitive: false,
            text: "",
            searchVisibleColumnsOnly: false
        }
    }),
    extenders: {
        controllers: {
            data: {
                publicMethods() {
                    return this.callBase().concat(["searchByText"])
                },
                _calculateAdditionalFilter() {
                    const filter = this.callBase();
                    const searchFilter = function(that, text) {
                        let i;
                        let column;
                        const columns = that._columnsController.getColumns();
                        const searchVisibleColumnsOnly = that.option("searchPanel.searchVisibleColumnsOnly");
                        let lookup;
                        const filters = [];
                        if (!text) {
                            return null
                        }

                        function onQueryDone(items) {
                            const valueGetter = compileGetter(lookup.valueExpr);
                            for (let i = 0; i < items.length; i++) {
                                const value = valueGetter(items[i]);
                                filters.push(column.createFilterExpression(value, null, "search"))
                            }
                        }
                        for (i = 0; i < columns.length; i++) {
                            column = columns[i];
                            if (searchVisibleColumnsOnly && !column.visible) {
                                continue
                            }
                            if (allowSearch(column) && column.calculateFilterExpression) {
                                lookup = column.lookup;
                                const filterValue = parseValue(column, text);
                                if (lookup && lookup.items) {
                                    dataQuery(lookup.items).filter(column.createFilterExpression.call({
                                        dataField: lookup.displayExpr,
                                        dataType: lookup.dataType,
                                        calculateFilterExpression: column.calculateFilterExpression
                                    }, filterValue, null, "search")).enumerate().done(onQueryDone)
                                } else if (void 0 !== filterValue) {
                                    filters.push(column.createFilterExpression(filterValue, null, "search"))
                                }
                            }
                        }
                        if (0 === filters.length) {
                            return ["!"]
                        }
                        return gridCoreUtils.combineFilters(filters, "or")
                    }(this, this.option("searchPanel.text"));
                    return gridCoreUtils.combineFilters([filter, searchFilter])
                },
                searchByText(text) {
                    this.option("searchPanel.text", text)
                },
                optionChanged(args) {
                    const that = this;
                    switch (args.fullName) {
                        case "searchPanel.text":
                        case "searchPanel":
                            that._applyFilter();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            }
        },
        views: {
            headerPanel: function() {
                const getSearchPanelOptions = function(that) {
                    return that.option("searchPanel")
                };
                return {
                    _getToolbarItems() {
                        const items = this.callBase();
                        return this._prepareSearchItem(items)
                    },
                    _prepareSearchItem(items) {
                        const that = this;
                        const dataController = that.getController("data");
                        const searchPanelOptions = getSearchPanelOptions(that);
                        if (searchPanelOptions && searchPanelOptions.visible) {
                            const toolbarItem = {
                                template(data, index, container) {
                                    const $search = $("<div>").addClass(that.addWidgetPrefix("search-panel")).appendTo(container);
                                    that.getController("editorFactory").createEditor($search, {
                                        width: searchPanelOptions.width,
                                        placeholder: searchPanelOptions.placeholder,
                                        parentType: "searchPanel",
                                        value: that.option("searchPanel.text"),
                                        updateValueTimeout: 700,
                                        setValue(value) {
                                            dataController.searchByText(value)
                                        },
                                        editorOptions: {
                                            inputAttr: {
                                                "aria-label": messageLocalization.format(that.component.NAME + "-ariaSearchInGrid")
                                            }
                                        }
                                    });
                                    that.resize()
                                },
                                name: "searchPanel",
                                location: "after",
                                locateInMenu: "never",
                                sortIndex: 40
                            };
                            items.push(toolbarItem)
                        }
                        return items
                    },
                    getSearchTextEditor() {
                        const that = this;
                        const $element = that.element();
                        const $searchPanel = $element.find("." + that.addWidgetPrefix("search-panel")).filter((function() {
                            return $(this).closest("." + that.addWidgetPrefix("header-panel")).is($element)
                        }));
                        if ($searchPanel.length) {
                            return $searchPanel.dxTextBox("instance")
                        }
                        return null
                    },
                    isVisible() {
                        const searchPanelOptions = getSearchPanelOptions(this);
                        return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                    },
                    optionChanged(args) {
                        if ("searchPanel" === args.name) {
                            if ("searchPanel.text" === args.fullName) {
                                const editor = this.getSearchTextEditor();
                                if (editor) {
                                    editor.option("value", args.value)
                                }
                            } else {
                                this._invalidate()
                            }
                            args.handled = true
                        } else {
                            this.callBase(args)
                        }
                    }
                }
            }(),
            rowsView: {
                init() {
                    this.callBase.apply(this, arguments);
                    this._searchParams = []
                },
                _getFormattedSearchText(column, searchText) {
                    const value = parseValue(column, searchText);
                    const formatOptions = gridCoreUtils.getFormatOptionsByColumn(column, "search");
                    return gridCoreUtils.formatValue(value, formatOptions)
                },
                _getStringNormalizer() {
                    const isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
                    return function(str) {
                        return isCaseSensitive ? str : str.toLowerCase()
                    }
                },
                _findHighlightingTextNodes(column, cellElement, searchText) {
                    const that = this;
                    let $parent = cellElement.parent();
                    let $items;
                    const stringNormalizer = this._getStringNormalizer();
                    const normalizedSearchText = stringNormalizer(searchText);
                    const resultTextNodes = [];
                    if (!$parent.length) {
                        $parent = $("<div>").append(cellElement)
                    } else if (column) {
                        if (column.groupIndex >= 0 && !column.showWhenGrouped) {
                            $items = cellElement
                        } else {
                            const columnIndex = that._columnsController.getVisibleIndex(column.index);
                            $items = $parent.children("td").eq(columnIndex).find("*")
                        }
                    }
                    $items = (null === $items || void 0 === $items ? void 0 : $items.length) ? $items : $parent.find("*");
                    $items.each((_, element) => {
                        const $contents = $(element).contents();
                        for (let i = 0; i < $contents.length; i++) {
                            const node = $contents.get(i);
                            if (3 === node.nodeType) {
                                const normalizedText = stringNormalizer(node.textContent || node.nodeValue);
                                if (normalizedText.indexOf(normalizedSearchText) > -1) {
                                    resultTextNodes.push(node)
                                }
                            }
                        }
                    });
                    return resultTextNodes
                },
                _highlightSearchTextCore($textNode, searchText) {
                    const that = this;
                    const $searchTextSpan = $("<span>").addClass(that.addWidgetPrefix("search-text"));
                    const text = $textNode.text();
                    const firstContentElement = $textNode[0];
                    const stringNormalizer = this._getStringNormalizer();
                    const index = stringNormalizer(text).indexOf(stringNormalizer(searchText));
                    if (index >= 0) {
                        if (firstContentElement.textContent) {
                            firstContentElement.textContent = text.substr(0, index)
                        } else {
                            firstContentElement.nodeValue = text.substr(0, index)
                        }
                        $textNode.after($searchTextSpan.text(text.substr(index, searchText.length)));
                        $textNode = $(domAdapter.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                        return that._highlightSearchTextCore($textNode, searchText)
                    }
                },
                _highlightSearchText(cellElement, isEquals, column) {
                    const that = this;
                    const stringNormalizer = this._getStringNormalizer();
                    let searchText = that.option("searchPanel.text");
                    if (isEquals && column) {
                        searchText = searchText && that._getFormattedSearchText(column, searchText)
                    }
                    if (searchText && that.option("searchPanel.highlightSearchText")) {
                        const textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
                        textNodes.forEach(textNode => {
                            if (isEquals) {
                                if (stringNormalizer($(textNode).text()) === stringNormalizer(searchText)) {
                                    $(textNode).replaceWith($("<span>").addClass(that.addWidgetPrefix("search-text")).text($(textNode).text()))
                                }
                            } else {
                                that._highlightSearchTextCore($(textNode), searchText)
                            }
                        })
                    }
                },
                _renderCore() {
                    const deferred = this.callBase.apply(this, arguments);
                    if (this.option().rowTemplate || this.option("dataRowTemplate")) {
                        if (this.option("templatesRenderAsynchronously")) {
                            clearTimeout(this._highlightTimer);
                            this._highlightTimer = setTimeout(() => {
                                this._highlightSearchText(this.getTableElement())
                            })
                        } else {
                            this._highlightSearchText(this.getTableElement())
                        }
                    }
                    return deferred
                },
                _updateCell($cell, parameters) {
                    const {
                        column: column
                    } = parameters;
                    const dataType = column.lookup && column.lookup.dataType || column.dataType;
                    const isEquals = "string" !== dataType;
                    if (allowSearch(column) && !parameters.isOnForm) {
                        if (this.option("templatesRenderAsynchronously")) {
                            if (!this._searchParams.length) {
                                clearTimeout(this._highlightTimer);
                                this._highlightTimer = setTimeout(() => {
                                    this._searchParams.forEach(params => {
                                        this._highlightSearchText.apply(this, params)
                                    });
                                    this._searchParams = []
                                })
                            }
                            this._searchParams.push([$cell, isEquals, column])
                        } else {
                            this._highlightSearchText($cell, isEquals, column)
                        }
                    }
                    this.callBase($cell, parameters)
                },
                dispose() {
                    clearTimeout(this._highlightTimer);
                    this.callBase()
                }
            }
        }
    }
};
